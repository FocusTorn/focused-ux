#!/usr/bin/env node

interface ScriptResult {
	script: string
	success: boolean
	output: string[]
	errors: string[]
	duration: number
	status: 'ran' | 'skipped' | 'failed'
	reason?: string
}

interface OrchestrationResult {
	overallSuccess: boolean
	results: ScriptResult[]
	totalDuration: number
	summary: {
		passed: number
		failed: number
		total: number
	}
}

class AssetGenerationOrchestrator {

	private verbose: boolean = false
	private veryVerbose: boolean = false
	private results: ScriptResult[] = []
	private startTime: number = 0

	constructor(verbose: boolean = false, veryVerbose: boolean = false) {
		this.verbose = verbose
		this.veryVerbose = veryVerbose
	}

	/**
	 * Execute asset generation scripts directly without spawning child processes
	 * This prevents MaxListenersExceededWarning by avoiding multiple process spawns
	 */
	private async executeAssetScript(scriptName: string, description: string, modelChangesDetected: boolean = false): Promise<ScriptResult> {
		const startTime = Date.now()
		
		if (this.verbose || this.veryVerbose) {
			console.log(`\nðŸ”„ Executing: ${description} (${scriptName})`)
			console.log('â”€'.repeat(60))
		}

		try {
			// Import and execute the script functions directly
			let success = false
			const output: string[] = []
			const errors: string[] = []

			// Capture console output temporarily for skip detection
			const originalLog = console.log
			const originalError = console.error
			
			// Always capture output for skip detection, but only suppress display in non-very-verbose mode
			console.log = (...args: unknown[]) => {
				const message = args.join(' ')

				output.push(message)
				if (this.veryVerbose) {
					originalLog(...args) // Show output in very verbose mode
				}
			}
			console.error = (...args: unknown[]) => {
				const message = args.join(' ')

				errors.push(message)
				if (this.veryVerbose) {
					originalError(...args) // Show errors in very verbose mode
				}
			}

			let status: 'ran' | 'skipped' | 'failed' = 'ran'
			let reason: string | undefined

			try {
				switch (scriptName) {
					case 'process-icons': {
						const { processIcons } = await import('./process-icons.js')

						await processIcons(this.verbose)
						success = true
						// Check if icons were actually processed by looking for "No icon changes detected" in output
						if (output.some(line => line.includes('No icon changes detected'))) {
							status = 'skipped'
							reason = 'No icon changes detected'
						}
						break
					}
					case 'generate-themes':
						if (!modelChangesDetected) {
							success = true
							status = 'skipped'
							reason = 'No model changes detected'
						} else {
							const { generateThemes } = await import('./generate-themes.js')

							await generateThemes(this.verbose)
							success = true
							status = 'ran'
						}
						break
					case 'generate-previews': {
						const { generatePreviews } = await import('./generate-previews.js')

						success = await generatePreviews('all', !this.verbose, false)
						// Check if previews were actually generated by looking for "already exist" in output
						if (output.some(line => line.includes('already exist'))) {
							status = 'skipped'
							reason = 'Preview images already exist'
						} else {
							status = 'ran'
						}
						break
					}
					case 'audit-models':
						if (!modelChangesDetected) {
							success = true
							status = 'skipped'
							reason = 'No recent changes detected'
						} else {
							const { validateModels } = await import('./audit-models.js')

							success = await validateModels(false)
							status = 'ran'
						}
						break
					case 'audit-themes':
						if (!modelChangesDetected) {
							success = true
							status = 'skipped'
							reason = 'No recent changes detected'
						} else {
							const { validateThemes } = await import('./audit-themes.js')

							success = await validateThemes()
							status = 'ran'
						}
						break
					default:
						throw new Error(`Unknown script: ${scriptName}`)
				}
			} catch (error) {
				success = false
				status = 'failed'
				reason = error instanceof Error ? error.message : String(error)
				errors.push(reason)
			} finally {
				// Restore console functions
				console.log = originalLog
				console.error = originalError
			}

			const duration = Date.now() - startTime

			const result: ScriptResult = {
				script: `${description} (${scriptName})`,
				success,
				output,
				errors,
				duration,
				status,
				reason,
			}

			if (this.verbose || this.veryVerbose) {
				this.displayScriptResult(result)
			}

			return result
		} catch (error) {
			const duration = Date.now() - startTime
			const result: ScriptResult = {
				script: `${description} (${scriptName})`,
				success: false,
				output: [],
				errors: [error instanceof Error ? error.message : String(error)],
				duration,
				status: 'failed',
				reason: error instanceof Error ? error.message : String(error),
			}

			if (this.verbose || this.veryVerbose) {
				this.displayScriptResult(result)
			}

			return result
		}
	}

	/**
	 * Display result for a single script
	 */
	private displayScriptResult(result: ScriptResult): void {
		let status: string
		let statusText: string
		
		switch (result.status) {
			case 'ran':
				status = '\x1B[32mâœ“\x1B[0m'
				statusText = 'Ran'
				break
			case 'skipped':
				status = '\x1B[32m\x1B[1mâ—\x1B[0m'
				statusText = 'Skipped'
				break
			case 'failed':
				status = '\x1B[31mâœ—\x1B[0m'
				statusText = 'Failed'
				break
		}
		
		const duration = `${result.duration}ms`
		const reasonText = result.reason ? ` - ${result.reason}` : ''
		
		console.log(`${status} ${result.script} (${statusText}, ${duration})${reasonText}`)
		
		if (!result.success && result.errors.length > 0) {
			console.log('   Errors:')
			result.errors.forEach(error => console.log(`   ${error}`))
		}
		
		if (this.veryVerbose && result.output.length > 0) {
			console.log('   Output:')
			result.output.forEach(line => console.log(`   ${line}`))
		}
	}

	/**
	 * Check if model files have changed using the same logic as generate-themes (timestamp comparison)
	 */
	private async checkModelChanges(): Promise<boolean> {
		try {
			const { promises: fs } = await import('fs')
			const path = await import('path')
			
			// Use the same paths as generate-themes
			const THEMES_DIR = path.resolve(process.cwd(), 'dist/assets/themes')
			const baseThemePath = path.join(THEMES_DIR, 'base.theme.json')
			const dynThemePath = path.join(THEMES_DIR, 'dynamicons.theme.json')
			
			// If theme files don't exist, generation is needed
			try {
				await fs.stat(baseThemePath)
				await fs.stat(dynThemePath)
			} catch {
				return true // Theme files don't exist, changes needed
			}
			
			// Get theme file timestamps
			const baseThemeStats = await fs.stat(baseThemePath)
			const dynThemeStats = await fs.stat(dynThemePath)
			const latestThemeTime = Math.max(baseThemeStats.mtime.getTime(), dynThemeStats.mtime.getTime())
			
			// Check model files for changes (same logic as generate-themes)
			const modelFiles = [
				path.resolve(process.cwd(), 'src/models/file_icons.model.json'),
				path.resolve(process.cwd(), 'src/models/folder_icons.model.json'),
				path.resolve(process.cwd(), 'src/models/language_icons.model.json'),
			]
			
			for (const modelFile of modelFiles) {
				try {
					const modelStats = await fs.stat(modelFile)

					if (modelStats.mtime.getTime() > latestThemeTime) {
						return true // Model file is newer than theme files
					}
				} catch {
					return true // Model file doesn't exist, assume changes needed
				}
			}
			
			return false // No changes detected - themes are up to date
		} catch (_error) {
			return true // If we can't determine, assume changes needed
		}
	}

	/**
	 * Execute the complete asset generation workflow using direct script execution
	 * This prevents MaxListenersExceededWarning by avoiding multiple process spawns
	 */
	async generateAssets(): Promise<OrchestrationResult> {
		this.startTime = Date.now()
		
		// Check for model changes once at the beginning
		const modelChangesDetected = await this.checkModelChanges()
		
		if (this.verbose || this.veryVerbose) {
			console.log('\nðŸŽ¨ [ASSET GENERATION ORCHESTRATOR]')
			console.log('â•'.repeat(60))
			console.log('ðŸ“‹ Workflow Steps:')
			console.log('   1. ðŸ”§ Process Icons (staging, organization, optimization)')
			console.log('   2. ðŸŽ¨ Generate Themes (base and dynamicons themes)')
			console.log('   3. ðŸ–¼ï¸  Generate Previews (preview images)')
			console.log('â•'.repeat(60))
			console.log('â„¹ï¸  Note: Using direct script execution to prevent process leaks')
			console.log(`â„¹ï¸  Model changes detected: ${modelChangesDetected ? 'Yes' : 'No'}`)
			console.log('â•'.repeat(60))
		}

		// Define the scripts to execute in order
		const scripts = [
			{ name: 'process-icons', description: 'Process Icons' },
			{ name: 'audit-models', description: 'Audit Models' },
			{ name: 'generate-themes', description: 'Generate Themes' },
			{ name: 'audit-themes', description: 'Audit Themes' },
			{ name: 'generate-previews', description: 'Generate Previews' },
		]

		// Execute each script sequentially using direct function calls
		for (const script of scripts) {
			const result = await this.executeAssetScript(script.name, script.description, modelChangesDetected)

			this.results.push(result)
			
			// Stop on first failure unless very verbose mode
			if (!result.success && !this.veryVerbose) {
				break
			}
		}

		const totalDuration = Date.now() - this.startTime
		const overallSuccess = this.results.every(r => r.success)
		
		const summary = {
			passed: this.results.filter(r => r.success).length,
			failed: this.results.filter(r => !r.success).length,
			total: this.results.length,
		}

		const orchestrationResult: OrchestrationResult = {
			overallSuccess,
			results: this.results,
			totalDuration,
			summary,
		}

		this.displayFinalResults(orchestrationResult)
		return orchestrationResult
	}

	/**
	 * Validate that asset generation results are present and correct
	 */
	private async validateAssetGenerationResults(): Promise<ScriptResult> {
		const startTime = Date.now()
		
		try {
			// Check if key output files exist
			const { promises: fs } = await import('fs')
			const path = await import('path')
			
			const expectedOutputs = [
				'assets/icons/file_icons',
				'assets/icons/folder_icons',
				'dist/assets/themes/base.theme.json',
				'dist/assets/themes/dynamicons.theme.json',
				'dist/assets/images/preview-images/File_icons_preview.png',
				'dist/assets/images/preview-images/Folder_icons_preview.png',
				'dist/assets/images/preview-images/Folder_Open_icons_preview.png',
			]
			
			const missingFiles: string[] = []
			
			for (const output of expectedOutputs) {
				const fullPath = path.resolve(process.cwd(), output)

				try {
					await fs.access(fullPath)
				} catch {
					missingFiles.push(output)
				}
			}
			
			const duration = Date.now() - startTime
			
			if (missingFiles.length === 0) {
				if (this.verbose || this.veryVerbose) {
					console.log('âœ… Asset generation validation passed - all outputs present')
				}
				return {
					script: 'Asset Generation Validation',
					success: true,
					status: 'ran',
					output: ['All expected outputs are present'],
					errors: [],
					duration,
				}
			} else {
				if (this.verbose || this.veryVerbose) {
					console.log('âŒ Asset generation validation failed - missing outputs:')
					missingFiles.forEach(file => console.log(`   â€¢ ${file}`))
				}
				return {
					script: 'Asset Generation Validation',
					success: false,
					status: 'failed',
					output: [],
					errors: [`Missing outputs: ${missingFiles.join(', ')}`],
					duration,
				}
			}
		} catch (error) {
			const duration = Date.now() - startTime

			return {
				script: 'Asset Generation Validation',
				success: false,
				status: 'failed',
				output: [],
				errors: [error instanceof Error ? error.message : String(error)],
				duration,
			}
		}
	}

	/**
	 * Display final orchestration results
	 */
	private displayFinalResults(result: OrchestrationResult): void {
		console.log(`\n${'â•'.repeat(60)}`)
		
		if (result.overallSuccess) {
			console.log('âœ… ASSET GENERATION COMPLETED SUCCESSFULLY')
		} else {
			console.log('âŒ ASSET GENERATION FAILED')
		}
		
		console.log('â•'.repeat(60))
		
		// Calculate statistics by status
		// const ranCount = result.results.filter(r => r.status === 'ran').length
		// const skippedCount = result.results.filter(r => r.status === 'skipped').length
		// const failedCount = result.results.filter(r => r.status === 'failed').length
		
		console.log(`ðŸ“Š Summary: ${result.summary.passed}/${result.summary.total} scripts passed`)
		console.log(`â±ï¸  Total Duration: ${result.totalDuration}ms`)
		console.log('â•'.repeat(60))
		
		// Always show detailed results
		console.log('ðŸ“‹ Detailed Results:')
		result.results.forEach((scriptResult, index) => {
			let status: string
			let statusText: string
			
			switch (scriptResult.status) {
				case 'ran':
					status = '\x1B[32mâœ“\x1B[0m'
					statusText = 'Ran'
					break
				case 'skipped':
					status = '\x1B[32m\x1B[1mâ—\x1B[0m'
					statusText = 'Skipped'
					break
				case 'failed':
					status = '\x1B[31mâœ—\x1B[0m'
					statusText = 'Failed'
					break
			}
			
			const duration = `${scriptResult.duration}ms`
			const reasonText = scriptResult.reason ? ` - ${scriptResult.reason}` : ''
			
			console.log(`   ${index + 1}. ${status} ${scriptResult.script} (${statusText}, ${duration})${reasonText}`)
			
			if (!scriptResult.success && scriptResult.errors.length > 0) {
				console.log('      Errors:')
				scriptResult.errors.forEach(error => console.log(`      ${error}`))
			}
		})
		console.log('â•'.repeat(60))
	}

	/**
	 * Get formatted results for external consumption
	 */
	getResults(): OrchestrationResult {
		return {
			overallSuccess: this.results.every(r => r.success),
			results: this.results,
			totalDuration: Date.now() - this.startTime,
			summary: {
				passed: this.results.filter(r => r.success).length,
				failed: this.results.filter(r => !r.success).length,
				total: this.results.length,
			},
		}
	}

}

function showHelp(): void {
	console.log(`
Asset Generation Orchestrator

Usage: npx tsx scripts/generate-assets.ts [options]

Options:
  --verbose, -v     Enable verbose output
  --very-verbose, -vv  Enable very verbose output (includes all script output)
  --help, -h        Show this help message

Examples:
  npx tsx scripts/generate-assets.ts
  npx tsx scripts/generate-assets.ts --verbose
  npx tsx scripts/generate-assets.ts --very-verbose

This orchestrator manages the complete asset generation workflow:
1. Process Icons (staging, organization, optimization)
2. Generate Themes (base and dynamicons themes)  
3. Generate Previews (preview images)

All scripts use intelligent caching and will skip when no changes are detected.
`)
}

// CLI interface
async function main(): Promise<void> {
	const args = process.argv.slice(2)

	// Check for explicit verbose flags or Nx verbose mode
	const verbose = args.includes('--verbose') || args.includes('-v')
	  || process.env.NX_VERBOSE_LOGGING === 'true'
	  || process.argv.some(arg => arg.includes('--verbose'))
	const veryVerbose = args.includes('--very-verbose') || args.includes('-vv')
	
	if (args.includes('--help') || args.includes('-h')) {
		showHelp()
		return
	}

	const orchestrator = new AssetGenerationOrchestrator(verbose, veryVerbose)
	const result = await orchestrator.generateAssets()
	
	// Exit with appropriate code
	process.exit(result.overallSuccess ? 0 : 1)
}

// Run if called directly
if (process.argv[1] && process.argv[1].endsWith('generate-assets.ts')) {
	main().catch((error) => {
		console.error('Asset generation failed:', error)
		process.exit(1)
	})
}

export { AssetGenerationOrchestrator }
export type { OrchestrationResult, ScriptResult }
