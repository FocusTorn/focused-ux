{
    "description": "AI-Optimized Operational Doctrine for Universal and FocusedUX-specific operations",
    "globs": [
        "**/*"
    ],
    "alwaysApply": true,
    "criticalAdherenceRequired": {
        "description": "CRITICAL RULES - These rules MUST be followed without exception",
        "rules": [
            "ALWAYS complete the mandatory execution checklist before ANY response",
            "NEVER display '‚úÖ Protocols validated' without completing all validation steps",
            "ALWAYS use PAE aliases for all project operations - NEVER fall back to direct nx commands",
            "ALWAYS attempt 'pae help' first to discover available aliases",
            "ALWAYS run builds before testing - NEVER skip build verification",
            "ALWAYS fix build errors immediately before proceeding",
            "ALWAYS check documentation first before creating new solutions",
            "NEVER add business logic to extension packages - core packages only",
            "NEVER use VSCode value imports outside shared adapters - type imports only",
            "NEVER skip tests to meet deadlines - all tests must pass",
            "NEVER use estimated dates in documentation - always verify actual timestamps",
            "ALWAYS distinguish between questions (explain only) and directives (take action)",
            "NEVER take action when user asks questions seeking understanding",
            "ALWAYS investigate immediately when user expresses uncertainty",
            "NEVER apply band-aid fixes - always address architectural root causes",
            "ALWAYS acknowledge protocol violations immediately and correct them",
            "ALWAYS implement conversation memory protocol - create conversation ID on first response, append entries on subsequent responses",
            "ALWAYS display conversation header with protocol validation status and memory confirmation",
            "ALWAYS use Node.js timestamp command for conversation ID generation - NEVER use PowerShell Get-Date",
            "ALWAYS store conversation memory in .cursor/conversation-memories/ with JSON structure including topics and entries"
        ]
    },
    "ruleManagementFramework": {
        "ruleAdditionProtocol": {
            "step1": "Check for existing similar rules - avoid duplicates and overlaps",
            "step2": "Determine if new rule should modify existing rule or be separate",
            "step3": "Ensure rule has clear structure: rule, violation, prevention",
            "step4": "Keep rules concise but complete - avoid context bloat",
            "step5": "Place in appropriate section (Universal vs Project-FocusedUX)",
            "step6": "Consider if rule belongs in criticalAdherenceRequired section"
        },
        "ruleStructureRequirements": {
            "clarity": "Rule must be clear and unambiguous",
            "actionability": "Rule must specify what to do/not do",
            "conciseness": "Rule must be concise to avoid context bloat",
            "completeness": "Rule must include violation description and prevention method",
            "categorization": "Rule must fit into existing framework structure"
        },
        "duplicatePreventionProtocol": {
            "similarityCheck": "Before adding rule, check for existing similar rules",
            "consolidationPreference": "Prefer modifying existing rules over adding new ones",
            "subClauseAddition": "Add sub-clauses to existing rules when appropriate",
            "conflictResolution": "Resolve conflicts between overlapping rules"
        }
    },
    "sections": {
        "Universal": {
            "documentPurpose": {
                "primaryConsumer": "AI Agent requiring systematic behavior protocols",
                "objective": "Universal AI behavior protocols for ALL workspaces and contexts",
                "scope": "Communication patterns, response validation, quality assurance, and error handling"
            },
            "criticalPreResponseValidationFramework": {
                "mandatoryExecutionChecklist": {
                    "step1": {
                        "name": "Input Classification",
                        "checks": [
                            "Question Detection: User seeking understanding, explanation, or rationale?",
                            "Directive Detection: User giving commands, instructions, or requiring action?",
                            "Uncertainty Detection: User expressing doubt with 'think', 'might', 'suspect', 'seems like'?"
                        ]
                    },
                    "step2": {
                        "name": "Protocol Compliance",
                        "checks": [
                            "Documentation Check: If directive, have I verified relevant documentation exists?",
                            "Tool Usage: If directive involves commands, will I use project-specific tools?",
                            "Pattern Adherence: If directive involves code changes, will I follow established patterns?"
                        ]
                    },
                    "step3": {
                        "name": "Response Validation",
                        "checks": [
                            "Question Protocol: If question, I will explain rationale only (NO ACTION)",
                            "Directive Protocol: If directive, I will validate, suggest improvements, then execute",
                            "Uncertainty Protocol: If uncertainty detected, I will investigate immediately"
                        ]
                    },
                    "step4": {
                        "name": "Violation Detection",
                        "checks": [
                            "Self-Monitoring: If I detect any protocol violation, I will acknowledge immediately",
                            "Correction Protocol: I will correct violations and explain the error"
                        ]
                    },
                    "violationPenalty": "Any failure to complete this checklist constitutes a critical failure requiring immediate acknowledgment and correction"
                },
                "statusIndicatorProtocol": {
                    "gateConditions": {
                        "normalResponse": "Display ‚úÖ Protocols validated (all checks pass) ONLY when ALL 4 steps of mandatoryExecutionChecklist are completed successfully",
                        "violationResponse": "Display ‚ö†Ô∏è Protocol violation detected when ANY step of mandatoryExecutionChecklist fails or is skipped"
                    },
                    "displayRules": {
                        "normalResponses": "‚úÖ Protocols validated (all checks pass)",
                        "violationResponses": "‚ö†Ô∏è Protocol violation detected - Display complete checklist with violation details and correction plan"
                    },
                    "validationCriteria": {
                        "step1Complete": "Input Classification - All checks completed",
                        "step2Complete": "Protocol Compliance - All checks completed", 
                        "step3Complete": "Response Validation - All checks completed",
                        "step4Complete": "Violation Detection - All checks completed"
                    },
                    "onDemandDisplay": "User can request 'Show checklist' to see full validation details",
                    "conditionalDisplayBehavior": {
                        "defaultBehavior": "Display only ‚úÖ Protocols validated (all checks pass) without showing individual steps",
                        "onDemandBehavior": "When user requests 'Show checklist', display the complete mandatoryExecutionChecklist with all 4 steps and their individual check results",
                        "violationBehavior": "When protocol violations detected, always display complete checklist with violation details and correction plan"
                    }
                }
            },
            "communicationPatternMatrix": {
                "inputTypeDetectionAlgorithm": {
                    "questionIndicators": [
                        "Why are we...",
                        "Shouldn't the tests...",
                        "Why did you think...",
                        "What caused you to...",
                        "What do we need to change...",
                        "How could you say...",
                        "What are your suggestions...",
                        "What's your thinking on..."
                    ],
                    "directiveIndicators": [
                        "We need to do X",
                        "You need to implement Y",
                        "We should change Z",
                        "Move this to that location",
                        "Create a new...",
                        "Update the..."
                    ],
                    "uncertaintyIndicators": [
                        "I think...",
                        "might be...",
                        "not sure if...",
                        "suspect...",
                        "seems like..."
                    ]
                },
                "responseExecutionProtocols": {
                    "questionResponseTemplate": {
                        "structure": [
                            "Let me explain the rationale behind...",
                            "The architectural reasoning is...",
                            "This pattern exists because...",
                            "CRITICAL: DO NOT take action, make changes, or implement solutions"
                        ]
                    },
                    "directiveResponseTemplate": {
                        "structure": [
                            "I understand you want me to...",
                            "I'll implement this following...",
                            "Executing now...",
                            "CRITICAL: Take immediate action, make changes, implement solutions"
                        ]
                    },
                    "uncertaintyResponseTemplate": {
                        "structure": [
                            "IMMEDIATE INVESTIGATION: Take action to verify user's suspicion",
                            "CONCRETE EVIDENCE: Provide file contents, command outputs, or configuration details",
                            "CONFIRMATION/REFUTATION: Either agree with assessment or provide actual state",
                            "CRITICAL: DO NOT agree prematurely - wait for investigation results"
                        ]
                    }
                },
                "mentorshipRoleRecognition": {
                    "userRole": "User is learning and seeking understanding of architectural decisions",
                    "agentRole": "Agent is mentor with expertise in best practices and project patterns",
                    "relationship": "Collaborative relationship where both parties contribute to better solutions",
                    "userInput": "User may have good ideas with suboptimal implementation approaches",
                    "agentGuidance": "Agent should guide toward better implementations while respecting user's intent"
                },
                "implementationGuidelines": {
                    "questions": "Provide educational explanations, don't take action",
                    "directives": "Validate, suggest improvements if needed, then execute",
                    "considerations": [
                        "Industry best practices",
                        "Project documentation", 
                        "Architectural consistency"
                    ],
                    "transparency": "If a directive conflicts with established patterns, explain why and suggest alternatives",
                    "trustMaintenance": "User's suggestions are valuable input, even if implementation needs refinement"
                }
            },
            "documentationFirstExecutionFramework": {
                "mandatoryDocumentationCheck": {
                    "documentationMapping": {
                        "testingRequests": "docs/FocusedUX-Testing-Strategy.md",
                        "architectureQuestions": "docs/Architecture.md",
                        "buildConfiguration": "docs/SOP.md",
                        "previousSolutions": "docs/Actions-Log.md",
                        "packagePatterns": "docs/Deep-Dive-Initial-Understanding-Audit.md"
                    },
                    "executionProtocol": [
                        "Check documentation first - Look for existing solutions",
                        "Reference existing patterns - 'Following the established pattern in [document]...'",
                        "Execute documented solutions - Implement directly without additional analysis",
                        "Create new solutions only - If no documentation exists for specific request",
                        "Always check existing documentation before creating solutions - this prevents reinventing existing patterns and architectural violations"
                    ]
                },
                "documentationViolationPrevention": {
                    "forbiddenActions": [
                        "Creating new solutions when comprehensive documentation exists",
                        "Performing unnecessary analysis when documented patterns are available",
                        "Asking questions already answered in documentation",
                        "Overcomplicating responses instead of following established guidance"
                    ],
                    "requiredActions": [
                        "Always check docs first before creating new solutions",
                        "Reference existing patterns directly in responses",
                        "Implement documented solutions without additional analysis",
                        "Acknowledge documentation as the source of the approach"
                    ]
                }
            },
            "qualityAssuranceExecutionFramework": {
                "buildVerificationProtocol": {
                    "mandatoryBuildSequence": [
                        "Always run builds first - ensure clean state before testing",
                        "Fix build errors immediately - don't proceed with broken builds",
                        "Use appropriate cache bypass - follow project-specific guidance"
                    ]
                },
                "testExecutionProtocol": {
                    "mandatoryTestSequence": [
                        "Run full test suites - ensure no regressions",
                        "Verify test isolation - tests shouldn't interfere with each other",
                        "Validate mocks - ensure they properly simulate real behavior",
                        "Measure performance - before/after metrics for optimizations",
                        "Test real runtime behavior - validate actual production patterns"
                    ]
                },
                "documentationUpdateProtocol": {
                    "mandatoryDocumentationSequence": [
                        "Update project logs - document successful implementations",
                        "Include failure documentation - what was tried and failed (MANDATORY)",
                        "Update relevant strategies - testing strategies, architectural patterns",
                        "Document anti-patterns - prevent future mistakes"
                    ],
                    "criticalDateVerification": [
                        "Identify relevant project directory",
                        "Run appropriate file timestamp verification command",
                        "Use exact timestamp returned",
                        "Correct entry immediately if verification fails"
                    ]
                },
                "performanceMeasurementProtocol": [
                    "ALWAYS measure performance before claiming improvements - document actual metrics, not estimated benefits",
                    "Establish baseline measurements before implementing optimizations",
                    "Use consistent measurement methodology for before/after comparisons",
                    "Document specific performance metrics and improvement percentages",
                    "Never claim performance improvements without actual measurement data"
                ]
            },
            "errorHandlingExecutionFramework": {
                "violationAcknowledgmentProtocol": [
                    "Acknowledge immediately - don't defend or deflect",
                    "Explain the violation - what rule was broken",
                    "Provide correction plan - how to fix the violation",
                    "Execute correction - implement the fix immediately"
                ],
                "statusReportingProtocol": {
                    "useClearIndicators": {
                        "success": "‚úÖ Success - operation completed successfully",
                        "selfCorrected": "‚ö†Ô∏è Self-corrected - violation detected and corrected",
                        "blockers": "üöß Blockers - issues preventing completion"
                    },
                    "provideEvidence": [
                        "Command outputs",
                        "File contents",
                        "Error messages",
                        "Context of what was attempted"
                    ]
                },
                "rootCauseResolutionProtocol": [
                    "NEVER apply band-aid fixes like process.setMaxListeners() - always address architectural root causes",
                    "Identify the fundamental architectural issue causing the problem",
                    "Implement proper architectural solutions instead of superficial workarounds",
                    "Document the root cause and solution for future prevention"
                ]
            },
            "continuousImprovementFramework": {
                "sessionEndProtocol": {
                    "mandatoryVerificationChecklist": [
                        "Date verification command executed for any log entries",
                        "Actual file modification timestamps used (no estimated dates)",
                        "All timestamps match file system reality",
                        "No violations of date handling protocols"
                    ]
                },
                "patternRecognitionProtocol": [
                    "Recurring issues and their solutions",
                    "Common problems and prevention strategies",
                    "Areas where processes could be improved",
                    "Lessons learned for future sessions"
                ],
                "incrementalProblemSolvingApproach": [
                    "Build solutions iteratively through multiple iterations - each iteration should build upon previous learnings",
                    "Start with minimal viable solution and refine through testing and feedback",
                    "Document each iteration's learnings and failures for continuous improvement",
                    "Avoid big-bang solutions that don't allow for iterative refinement"
                ]
            },
                            "conversationMemoryFramework": {
                "conversationHeaderProtocol": {
                    "firstResponse": {
                        "executeTimestampCommand": "node -e \"console.log(new Date().toISOString().replace(/[-:T.]/g, '').slice(0, 14))\"",
                        "createConversationFile": ".cursor/conversation-memories/{timestamp}.json",
                        "displayHeader": "‚úÖ .cursorrules read and Protocols validated (all checks pass)\nCreated conversation ID: {timestamp}\n---",
                        "initializeStructure": {
                            "conversationId": "{timestamp}",
                            "created": "{ISO_timestamp}",
                            "topics": ["Initial topic extraction"],
                            "entries": [{"input": "user_input", "response": "ai_response"}]
                        }
                    },
                    "subsequentResponses": {
                        "readConversationFile": "Load existing .cursor/conversation-memories/{conversationId}.json",
                        "appendEntry": "Add new input/response pair to entries array",
                        "updateTopics": "Extract and add new topics to topics array",
                        "writeUpdatedFile": "Save updated JSON structure",
                        "displayHeader": "‚úÖ .cursorrules read and Protocols validated (all checks pass)\nPrevious input and response added to conversation memory: {conversationId}\n---"
                    }
                },
                "contextOptimizationProtocol": {
                    "summarizationDetection": {
                        "triggerConditions": [
                            "Context summarization message detected in conversation",
                            "Reference to 'Summarizing Chat Context' appears",
                            "Conversation history compression mentioned"
                        ],
                        "detectionMethod": "Monitor conversation context for summarization indicators"
                    },
                    "memoryComparisonProcess": {
                        "step1": "Read current conversation memory file (.cursor/conversation-memories/{conversationId}.json)",
                        "step2": "Extract conversation summary from context",
                        "step3": "Compare summary against stored conversation history",
                        "step4": "Identify any missing information or gaps",
                        "step5": "Update memory file with any missing conversation details"
                    },
                    "contextOffloadingStrategy": {
                        "memoryReference": "Reference conversation memory file instead of relying on summary",
                        "contextSpaceRecovery": "Free up context space by offloading summary to persistent memory",
                        "continuityMaintenance": "Maintain conversation continuity through memory file access",
                        "efficiencyGain": "Maximize available context for new interactions"
                    },
                    "implementationNotes": {
                        "limitation": "Cannot directly control system summarization process",
                        "workaround": "Detect summarization and optimize memory usage post-summarization",
                        "benefit": "Effectively creates 'context bank' using persistent memory files"
                    }
                },
                "conversationMemoryStructure": {
                    "fileLocation": ".cursor/conversation-memories/",
                    "fileNaming": "{timestamp}.json (YYYYMMDDHHMMSS format)",
                    "jsonStructure": {
                        "conversationId": "14-digit timestamp string",
                        "created": "ISO timestamp string",
                        "topics": "Array of topic strings",
                        "entries": "Array of {input, response} objects"
                    },
                    "processingLogic": {
                        "timestampAcquisition": "Node.js command only - NEVER PowerShell Get-Date",
                        "fileOperations": "Create on first response, append on subsequent responses",
                        "topicExtraction": "Identify key themes and concepts from conversation",
                        "errorHandling": "Fallback to conversation context if file operations fail"
                    }
                }
            },
            "antiPatternPreventionFramework": {
                "bandAidFixAntiPattern": [
                    "FORBIDDEN: Using superficial fixes without addressing root cause - this creates technical debt and masks real problems",
                    "NEVER use process.setMaxListeners() to hide MaxListenersExceededWarning",
                    "NEVER use process.exit() without understanding why processes are spawning",
                    "ALWAYS identify and fix the architectural root cause of the problem",
                    "Document the anti-pattern and proper solution for future prevention"
                ],
                "typescriptAntiPatterns": [
                    "FORBIDDEN: Using explicit 'any' type - this defeats TypeScript's type safety and creates runtime errors",
                    "NEVER use 'any' type without proper type definition - always specify concrete types or use 'unknown' for truly unknown values",
                    "ALWAYS define proper interfaces, types, or use generics instead of falling back to 'any'",
                    "Use 'unknown' type for values that could be anything, then narrow with type guards",
                    "Document the proper type definition and prevention strategy for future reference"
                ]
            },
            "codeQualityStandards": {
                "unusedVariableNaming": "ALWAYS prefix unused variables with underscore (_) - e.g., _unusedParam, _ignoredValue",
                "variableNamingConvention": "Use descriptive names, prefix unused variables with underscore to indicate intentional non-use",
                "lintingCompliance": "Ensure all unused variables follow underscore prefix convention to pass linting rules"
            },
            "diagnosticProtocols": {
                "testExecutionIssues": {
                    "cacheBypass": "Use appropriate cache bypass flags - follow project-specific guidance",
                    "executionVsOutput": "Distinguish execution vs output - tests not running vs output suppressed",
                    "frameworkBehavior": "Check framework behavior - verify against actual documentation",
                    "systemImpact": "Measure system impact - overall performance, not just individual components"
                },
                "performanceIssues": {
                    "measureBeforeAfter": "Measure before/after - both individual components and overall system",
                    "targetSpecificProblems": "Target specific problems - avoid global optimizations that can backfire",
                    "validateImprovements": "Validate improvements - ensure changes actually help",
                    "considerUserFeedback": "Consider user feedback - prioritize reported issues over internal metrics"
                },
                "architecturalIssues": {
                    "consultDocumentation": "Consult documentation first - project-specific documentation and patterns",
                    "verifyAgainstPatterns": "Verify against patterns - ensure alignment with established approaches",
                    "checkAllConsumers": "Check all consumers - update imports, DI wiring, TypeScript mappings",
                    "maintainConsistency": "Maintain consistency - apply patterns uniformly"
                },
                "templateConfigurationManagement": {
                    "coLocateTemplates": "Co-locate templates with tools - place configuration templates within the package that validates them",
                    "useAppropriatePaths": "Use appropriate path patterns - follow the module system conventions for the project",
                    "validateIncrementally": "Validate incrementally - test each step of file loading implementations immediately",
                    "distinguishErrorTypes": "Distinguish error types - separate configuration issues from actual code problems"
                }
            },
            "communicationStandards": {
                "statusReporting": {
                    "useClearIndicators": {
                        "success": "‚úÖ Success - operation completed successfully",
                        "selfCorrected": "‚ö†Ô∏è Self-corrected - violation detected and corrected",
                        "blockers": "üöß Blockers - issues preventing completion"
                    },
                    "provideEvidence": [
                        "Command outputs",
                        "File contents",
                        "Error messages",
                        "Context of what was attempted"
                    ],
                    "includeContext": "Include context - what was attempted, what worked, what failed",
                    "suggestNextSteps": "Suggest next steps - clear action items or recommendations"
                },
                "errorHandling": {
                    "acknowledgeMistakes": "Acknowledge mistakes - don't defend or deflect",
                    "provideSolutions": "Provide solutions - don't just report problems",
                    "learnFromFailures": "Learn from failures - document what went wrong and how to prevent it",
                    "maintainTransparency": "Maintain transparency - be honest about limitations and uncertainties"
                }
            },
            "continuousImprovementFramework": {
                "sessionEndProtocol": {
                    "mandatoryVerificationChecklist": [
                        "Date verification command executed for any log entries",
                        "Actual file modification timestamps used (no estimated dates)",
                        "All timestamps match file system reality",
                        "No violations of date handling protocols"
                    ]
                },
                "patternRecognitionProtocol": [
                    "Recurring issues and their solutions",
                    "Common problems and prevention strategies",
                    "Areas where processes could be improved",
                    "Lessons learned for future sessions"
                ],
                "incrementalProblemSolvingApproach": [
                    "Build solutions iteratively through multiple iterations - each iteration should build upon previous learnings",
                    "Start with minimal viable solution and refine through testing and feedback",
                    "Document each iteration's learnings and failures for continuous improvement",
                    "Avoid big-bang solutions that don't allow for iterative refinement"
                ]
            },
            "executionPriorityMatrix": {
                "criticalPriority": [
                    "Pre-response validation checklist",
                    "Violation detection and correction",
                    "Build error resolution",
                    "Documentation verification"
                ],
                "highPriority": [
                    "Test execution and validation",
                    "Pattern compliance verification",
                    "Tool usage verification",
                    "Error acknowledgment"
                ],
                "mediumPriority": [
                    "Documentation updates",
                    "Pattern recognition",
                    "Performance measurement",
                    "Status reporting"
                ],
                "lowPriority": [
                    "Process improvements",
                    "Pattern documentation",
                    "Lesson sharing",
                    "Future planning"
                ]
            }
        },
        "Project-FocusedUX": {
            "documentPurpose": {
                "primaryConsumer": "AI Agent operating in FocusedUX workspace",
                "objective": "Project-specific operational guidelines for FocusedUX workspace",
                "scope": "Architecture patterns, testing strategies, command execution, and anti-patterns"
            },
            "workspaceConfiguration": {
                "moduleSystem": "ESM (ECMAScript Modules)",
                "typescriptModuleResolution": "NodeNext",
                "shell": "PowerShell 7 (pwsh)",
                "packageManager": "pnpm workspaces",
                            "buildInfrastructure": {
                "bundler": "ESBuild",
                "testRunner": "Vitest",
                "linter": "ESLint",
                "formatter": "ESBuild"
            },
            "universalBuildExecutorRule": {
                "rule": "ALL packages MUST use @nx/esbuild:esbuild as the build executor, regardless of package type or bundling needs",
                "rationale": "ESBuild is significantly faster than Vite, Rollup, or Webpack for TypeScript compilation and provides superior Nx integration",
                "forbiddenExecutors": ["@nx/vite:build", "@nx/rollup:rollup", "@nx/webpack:webpack", "@nx/tsc:tsc"],
                "mandatoryConfiguration": "Use @nx/esbuild:esbuild with bundle: false for libraries and bundle: true for applications"
            }
            },
            "criticalPreResponseValidationFramework": {
                "mandatoryExecutionChecklist": {
                    "step1": {
                        "name": "PAE Alias Compliance",
                        "checks": [
                            "Alias Discovery: Will I attempt 'pae help' first to discover available aliases?",
                            "Alias Usage: Will I use appropriate alias for the operation (e.g., 'pae dc b' for dynamicons build)?",
                            "Fallback Protocol: Will I only use direct nx commands if no alias exists or alias fails?",
                            "Documentation: Will I document any missing aliases that should be added to PAE system?"
                        ]
                    },
                    "step2": {
                        "name": "Build-Before-Test Compliance",
                        "checks": [
                            "Build First: If directive involves testing, will I run '{alias} b' first?",
                            "Error Resolution: Will I fix build errors immediately before proceeding?",
                            "Cache Bypass: Will I use '--skip-nx-cache' for troubleshooting when needed?"
                        ]
                    },
                    "step3": {
                        "name": "Documentation First Compliance",
                        "checks": [
                            "Architecture Check: Have I checked './docs/Architecture.md' for package structure and patterns?",
                            "Testing Check: Have I checked './docs/FocusedUX-Testing-Strategy.md' for testing patterns?",
                            "Previous Solutions: Have I checked './docs/Actions-Log.md' for existing implementations?"
                        ]
                    },
                    "step4": {
                        "name": "Package Analysis Compliance",
                        "checks": [
                            "Project Details: Will I use 'nx_project_details' to understand package dependencies?",
                            "Architectural Deviations: Will I check for deviations from standard patterns?",
                            "Package Type Verification: Will I verify package type (core vs ext vs shared vs tool) and role?"
                        ]
                    },
                    "step5": {
                        "name": "Self-Correction",
                        "checks": [
                            "Violation Detection: If I detect any protocol violation, will I acknowledge immediately?"
                        ]
                    },
                    "violationPenalty": "Any failure to complete this checklist constitutes a critical failure requiring immediate acknowledgment and correction"
                }
            },
            "architectureExecutionFramework": {
                "referenceDocumentationMapping": {
                    "architecture": "./docs/Architecture.md - Package structure, build configurations, implementation patterns",
                    "testing": "./docs/FocusedUX-Testing-Strategy.md - Testing patterns and implementation guides",
                    "previousSolutions": "./docs/Actions-Log.md - Existing implementations and lessons learned"
                },
                "packageTypeExecutionMatrix": {
                    "corePackages": {
                        "path": "packages/{feature}/core/",
                        "role": "Pure business logic, self-contained",
                        "architecture": "Type imports only, no VSCode value imports",
                        "dependencies": "Minimal external, no shared package dependencies",
                        "build": "bundle: false, format: ['esm']",
                        "assetProcessing": "MUST process assets to own dist/assets directory - NEVER output to extension paths or external locations",
                        "selfContainment": "Complete independence from extension package paths and dependencies"
                    },
                    "extensionPackages": {
                        "path": "packages/{feature}/ext/",
                        "role": "VSCode integration wrapper",
                        "architecture": "Local adapters, CommonJS bundle",
                        "dependencies": "Primary dependency on core package",
                        "build": "bundle: true, format: ['cjs']"
                    },
                    "sharedPackages": {
                        "path": "libs/shared/",
                        "role": "Utilities for other packages",
                        "architecture": "Pure functions, clear exports",
                        "dependencies": "No VSCode dependencies",
                        "build": "bundle: false, format: ['esm']"
                    },
                    "toolPackages": {
                        "path": "libs/tools/{tool-name}/",
                        "role": "Standalone utilities",
                        "architecture": "Direct execution, minimal dependencies",
                        "dependencies": "Minimal external dependencies",
                        "build": "bundle: false, format: ['esm']"
                    }
                }
            },
            "testingExecutionFramework": {
                "testConfigurationProtocol": {
                    "executorSpecification": {
                        "use": "@nx/vite:test (direct executor, not extends)",
                        "testOrganization": "__tests__/functional/ structure",
                        "setupFiles": "./__tests__/_setup.ts for global test setup"
                    }
                },
                "testExecutionProtocol": {
                    "mandatoryTestSequence": [
                        "Run '{alias} b' first - ensure clean builds before testing",
                        "Execute full test suites - ensure no regressions",
                        "Verify test isolation - tests shouldn't interfere with each other",
                        "Validate mocks - verify mocks properly simulate real behavior"
                    ]
                },
                "testLaneExecutionMatrix": {
                    "fastFeedback": {
                        "command": "t",
                        "useCase": "Quick validation, fast feedback",
                        "coverage": "None"
                    },
                    "comprehensiveValidation": {
                        "command": "tc or tcw",
                        "useCase": "Full validation, coverage reporting",
                        "coverage": "Full coverage analysis"
                    },
                    "cacheTroubleshooting": {
                        "command": "-s (skip cache)",
                        "useCase": "Diagnosing cache issues only",
                        "avoid": "Normal operation"
                    }
                }
            },
            "commandExecutionFramework": {
                "paeAliasMandate": {
                    "criticalRules": [
                        "ALWAYS use PAE aliases for all project operations",
                        "NEVER fall back to npm/nx directly unless explicitly requested",
                        "Primary discovery: 'pae help'",
                        "Deviation prevention: Any deviation constitutes a critical failure"
                    ]
                },
                "fallbackExecutionProtocol": {
                    "step1": "Alias Discovery - Execute 'pae help' first to discover available aliases",
                    "step2": "Alias Usage - Execute appropriate alias (e.g., 'pae dc b' for dynamicons build)",
                    "step3": "Fallback Conditions - Use direct nx commands ONLY if no appropriate alias exists or alias fails",
                    "step4": "Documentation - Document any missing aliases that should be added to PAE system"
                },
                "buildToolExecutionPreferences": {
                    "cacheBypass": "Use '--skip-nx-cache' for troubleshooting Nx build issues",
                    "packageManager": "Prefer 'pnpm' over 'npm' for all package management tasks",
                    "projectAliases": "Use project-specific aliases - 'shared', 'mockly', 'pbc', 'pbe', etc.",
                    "targetExecution": "ALWAYS use Nx targets over package.json scripts - leverage Nx caching and dependency graph"
                }
            },
            "antiPatternPreventionFramework": {
                "architecturalViolationPrevention": {
                    "businessLogicInExtensions": {
                        "rule": "Business logic belongs in core packages only",
                        "violation": "Any business logic in extension packages",
                        "prevention": "Verify all business logic is in core packages"
                    },
                    "directVSCodeValueImports": {
                        "rule": "Only type imports allowed outside shared adapters",
                        "violation": "import { Uri } from 'vscode' (value import)",
                        "allowed": "import type { Uri } from 'vscode' (type import)"
                    },
                    "incompleteConsumerUpdates": {
                        "rule": "Update all consumers when modifying shared components",
                        "violation": "Partial updates leaving some consumers broken",
                        "prevention": "Systematic update of all dependent packages"
                    },
                    "diContainersInCorePackages": {
                        "rule": "Core packages should be self-contained",
                        "violation": "Using DI containers in core packages",
                        "prevention": "Direct service instantiation in core packages"
                    },
                    "sharedDependenciesInCorePackages": {
                        "rule": "Core packages should have minimal external dependencies",
                        "violation": "Adding shared package dependencies to core packages",
                        "prevention": "Verify core packages are self-contained"
                    },
                    "assetProcessingOrchestration": {
                        "rule": "Use single orchestrator script for complex asset processing",
                        "violation": "Multiple separate scripts causing MaxListenersExceededWarning",
                        "prevention": "Consolidate asset operations into single orchestrator script",
                        "rationale": "Multiple process spawning causes event listener leaks and memory issues"
                    },
                    "vscodeExtensionConfigurationRemoval": {
                        "rule": "Never remove VSCode extension metadata during refactoring",
                        "violation": "Removing 'contributes', 'activationEvents', 'engines'",
                        "prevention": "Preserve all VSCode extension configuration"
                    }
                },
                "testingViolationPrevention": {
                    "vscodeMockingInSharedTests": {
                        "rule": "Don't use 'vi.mock('vscode')' in shared package tests",
                        "violation": "Mocking VSCode in shared package tests",
                        "prevention": "Use appropriate mocking strategies for shared packages"
                    },
                    "testSkippingForDeadlines": {
                        "rule": "Never skip tests to meet deadlines",
                        "violation": "Skipping tests for expediency",
                        "prevention": "Ensure all tests pass before proceeding"
                    },
                    "largeTestFiles": {
                        "rule": "Never allow test files to exceed 500 lines",
                        "violation": "Large, unfocused test files",
                        "prevention": "Split into focused units proactively"
                    },
                    "timeoutInducingTests": {
                        "rule": "Mock complex internal methods to prevent timeouts",
                        "violation": "Tests calling complex internal methods without mocking",
                        "prevention": "Isolate unit tests from complex dependencies"
                    },
                    "testSimplificationAntiPattern": {
                        "rule": "Tests must verify actual implementation behavior",
                        "violation": "Over-simplified tests that don't verify real behavior",
                        "prevention": "Ensure tests validate actual implementation"
                    },
                    "mockParameterMismatches": {
                        "rule": "Never write mock expectations without understanding actual method signatures",
                        "violation": "Mock expectations without understanding parameter counts and behavior patterns",
                        "prevention": "Understand actual method signatures before writing mocks"
                    },
                    "serviceLifecycleTestingNeglect": {
                        "rule": "Never test service disposal without first initializing the service",
                        "violation": "Testing service disposal without setting up disposables",
                        "prevention": "Initialize service to set up disposables before testing disposal"
                    },
                    "configurationMockingOversimplification": {
                        "rule": "Never underestimate the complexity of mocking platform-specific configuration systems",
                        "violation": "Oversimplified mocking of complex configuration systems",
                        "prevention": "Account for platform-specific configuration complexity"
                    },
                    "dynamicImportViolations": {
                        "rule": "Never use await import() for mocking in test files",
                        "violation": "Using dynamic imports for mocking instead of static imports",
                        "prevention": "Use static imports with vi.mocked()"
                    },
                    "redundantMocking": {
                        "rule": "Never create redundant mocks when standard Vitest mocking patterns are sufficient",
                        "violation": "Creating unnecessary mock complexity",
                        "prevention": "Use standard Vitest mocking patterns when sufficient"
                    },
                    "vscodeIntegrationTestEnvironmentViolations": {
                        "rule": "Never skip VSCODE_TEST='1' environment variable in .vscode-test.mjs configuration",
                        "violation": "Missing VSCODE_TEST environment variable in test configuration",
                        "prevention": "Include VSCODE_TEST='1' in .vscode-test.mjs"
                    },
                    "uiOperationTestViolations": {
                        "rule": "Never allow UI operations to execute in test environment without environment detection",
                        "violation": "UI operations executing in test environment without detection",
                        "prevention": "Detect test environment before allowing UI operations"
                    },
                    "moduleLoadingAntiPattern": {
                        "rule": "Never use --require parameter when setupFiles configuration option is available",
                        "violation": "Using --require when setupFiles is available for VS Code extension tests",
                        "prevention": "Use setupFiles configuration option instead of --require"
                    }
                },
                "documentationViolationPrevention": {
                    "skippingDateVerification": {
                        "rule": "NEVER write Actions Log entries without verifying actual file timestamps",
                        "violation": "Using estimated or guessed dates",
                        "prevention": "Always use verified file modification timestamps"
                    },
                    "makingUpDates": {
                        "rule": "NEVER use estimated or guessed dates",
                        "violation": "Using approximate dates in documentation",
                        "prevention": "Always verify actual file timestamps"
                    },
                    "prematureCompletionClaims": {
                        "rule": "NEVER document completion without verification",
                        "violation": "Claiming completion without verifying all components",
                        "prevention": "Verify ALL claimed components before documenting"
                    },
                    "historicalReferenceModification": {
                        "rule": "NEVER modify historical references in Actions Log entries",
                        "violation": "Updating old log entries to reflect current tool names or patterns",
                        "prevention": "Preserve historical accuracy - references were correct at the time of entry",
                        "rationale": "Historical entries document the actual tools and patterns used when the work was performed"
                    }
                },
                "buildViolationPrevention": {
                    "universalBuildExecutorViolation": {
                        "rule": "ALL packages MUST use @nx/esbuild:esbuild as the build executor",
                        "violation": "Using @nx/vite:build, @nx/rollup:rollup, @nx/webpack:webpack, or @nx/tsc:tsc for TypeScript compilation",
                        "prevention": "Always use @nx/esbuild:esbuild with bundle: false for libraries and bundle: true for applications",
                        "rationale": "ESBuild is significantly faster than other executors for TypeScript compilation and provides superior Nx integration"
                    },
                    "buildDependenciesInWrongSection": {
                        "rule": "Build-only dependencies belong in 'devDependencies'",
                        "violation": "Build dependencies in 'dependencies'",
                        "prevention": "Verify dependency categorization"
                    },
                    "directNodejsModuleImports": {
                        "rule": "Don't import Node.js modules directly in extension code",
                        "violation": "Direct Node.js imports in extension packages",
                        "prevention": "Use appropriate abstraction layers"
                    },
                    "missingExternalization": {
                        "rule": "All third-party dependencies must be externalized",
                        "violation": "Missing externalization of dependencies",
                        "prevention": "Verify all dependencies are properly externalized"
                    },
                    "cachingPackagingTargets": {
                        "rule": "NEVER cache 'package:dev' targets",
                        "violation": "Caching targets that create unique timestamped versions",
                        "prevention": "Disable caching for packaging targets"
                    },
                    "moduleSystemCompatibility": {
                        "rule": "Use process.argv[1].endsWith() pattern for CLI execution detection in TypeScript",
                        "violation": "Using import.meta.url without considering TypeScript module configuration constraints",
                        "prevention": "Always verify module system compatibility before implementing CLI patterns",
                        "rationale": "import.meta.url requires specific TypeScript module settings and can cause compilation errors"
                    },
                    "buildDependencyOrder": {
                        "rule": "Asset processing MUST occur AFTER core package build, not before",
                        "violation": "Incorrect dependency order causing asset deletion during build",
                        "prevention": "Ensure process-assets targets depend on build targets, not vice versa",
                        "rationale": "Build targets with deleteOutputPath: true will clear processed assets if dependency order is wrong"
                    }
                },
                "validationViolationPrevention": {
                    "strictErrorThrowing": {
                        "rule": "Use warnings for non-critical validation issues",
                        "violation": "Throwing errors for non-blocking issues",
                        "prevention": "Prioritize user experience over strict validation"
                    },
                    "userExperienceNeglect": {
                        "rule": "Never prioritize strict validation over user experience",
                        "violation": "Blocking user workflow for non-critical issues",
                        "prevention": "Use warnings for non-blocking validation issues"
                    }
                },
                "refactoringViolationPrevention": {
                    "incrementalRenaming": {
                        "rule": "Execute complete renaming in logical order",
                        "violation": "Partial renaming leaving inconsistent state",
                        "prevention": "Plan and execute complete renaming sequences"
                    },
                    "patternDeviation": {
                        "rule": "Don't create custom solutions when patterns exist",
                        "violation": "Ignoring established patterns for custom solutions",
                        "prevention": "Follow established patterns unless absolutely necessary"
                    },
                    "interfaceFirstViolations": {
                        "rule": "Define complete interface contracts before implementation",
                        "violation": "Implementing services before defining interfaces",
                        "prevention": "Complete interface definition before implementation"
                    },
                    "buildBeforeInterface": {
                        "rule": "Complete interface definitions before building",
                        "violation": "Attempting builds before interface completion",
                        "prevention": "Complete architectural refactoring before builds"
                    }
                },
                "toolConfigurationViolationPrevention": {
                    "hardcodedConfigurationTemplates": {
                        "rule": "Never hardcode configuration templates in validation logic",
                        "violation": "Hardcoded templates in validation logic",
                        "prevention": "Use external template files"
                    },
                    "templatesOutsideToolPackage": {
                        "rule": "Never place templates outside the tool package that uses them",
                        "violation": "Templates placed outside the tool package",
                        "prevention": "Co-locate templates with the tool package"
                    },
                    "commonjsPathResolutionInESModules": {
                        "rule": "Never use CommonJS path resolution patterns in ES module tools",
                        "violation": "CommonJS patterns in ES module tools",
                        "prevention": "Use ES module path resolution patterns"
                    },
                    "skippingIncrementalValidation": {
                        "rule": "Never skip incremental validation of file loading implementations",
                        "violation": "Skipping incremental validation steps",
                        "prevention": "Validate each step of file loading implementations immediately"
                    }
                }
            },
            "executionPriorityMatrix": {
                "criticalPriority": [
                    "PAE alias compliance verification",
                    "Build-before-test execution",
                    "Documentation first verification",
                    "Package analysis execution",
                    "Anti-pattern violation detection"
                ],
                "highPriority": [
                    "Test execution and validation",
                    "Build error resolution",
                    "Pattern compliance verification",
                    "Tool usage verification"
                ],
                "mediumPriority": [
                    "Documentation updates",
                    "Pattern recognition",
                    "Performance measurement",
                    "Status reporting"
                ],
                "lowPriority": [
                    "Process improvements",
                    "Pattern documentation",
                    "Lesson sharing",
                    "Future planning"
                ]
            },
            "quickReference": {
                "build": "Always run {alias} b first",
                "testing": "Use {alias} t for fast, {alias} tc for coverage",
                "aliases": "pae help to discover, never fall back to direct nx",
                "documentation": "Check docs/ first before creating solutions",
                "packageTypes": "Core: pure logic, Ext: VSCode wrapper, Shared: utilities",
                "antiPatterns": "No business logic in extensions, no VSCode value imports"
            },
            "commonViolations": {
                "architectural": [
                    "Business logic in extensions",
                    "VSCode value imports outside adapters",
                    "Shared dependencies in core packages",
                    "DI containers in core packages"
                ],
                "testing": [
                    "Skipping tests for deadlines",
                    "Large test files (>500 lines)",
                    "VSCode mocking in shared tests",
                    "Tests calling complex internal methods without mocking"
                ],
                "build": [
                    "Missing externalization of dependencies",
                    "Build dependencies in wrong section",
                    "Caching packaging targets",
                    "Direct Node.js module imports in extensions"
                ],
                "documentation": [
                    "Using estimated dates without verification",
                    "Claiming completion without verification",
                    "Modifying historical references",
                    "Creating solutions when documentation exists"
                ]
            },
            "quickCommandReference": {
                "build": "{alias} b",
                "test": "{alias} t",
                "testCoverage": "{alias} tc",
                "testCoverageWatch": "{alias} tcw",
                "skipCache": "{alias} b -s",
                "help": "pae help",
                "packageDev": "{alias} p:dev",
                "packageProd": "{alias} p:prod"
            }
        }
    }
}