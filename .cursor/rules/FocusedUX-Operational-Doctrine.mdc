---
alwaysApply: true
---

# FocusedUX Operational Doctrine

## **Project Architecture**

### **File Organization**

- **Packages**: `packages/` directory (extensions, core packages)
- **Libraries**: `libs/` directory (shared, mockly, tools)
- **Documentation**: `docs/` directory (strategies, logs, SOPs)
- **Configuration**: Root-level configs (`.cursor/rules/`, `nx.json`, etc.)

### **Package Archetypes**

- **`shared` (Library)**: Located in `libs/shared/`, contains shared services and abstractions for runtime use by other packages
- **`core` (Library)**: Located in `packages/{feature}/core/`, contains feature's abstract business logic, built to be tree-shakeable
- **`ext` (Application)**: Located in `packages/{feature}/ext/`, contains VSCode extension implementation, depends on core package
- **`tool` (Utility)**: Located in `libs/tools/{tool-name}/`, contains standalone utilities that run directly with tsx (no build step)

### **Package Structure Decision Tree**

```
Is the package intended to be a VS Code extension?
├─ YES → Use core/ext pattern (packages/{feature}/core + packages/{feature}/ext)
│   ├─ core: Library with business logic, built with @nx/esbuild:esbuild (bundle: false)
│   └─ ext: Application bundle, built with @nx/esbuild:esbuild (bundle: true)
│
├─ NO → Is the package a shared library consumed by other packages?
│   ├─ YES → Use shared pattern (libs/shared)
│   │   └─ Built with @nx/esbuild:esbuild (bundle: false), generates declarations
│   │
│   └─ NO → Is the package a standalone tool/utility that runs directly?
│       ├─ YES → Use tool pattern (libs/tools/{tool-name})
│       │   ├─ Runs directly with tsx (no build step)
│       │   ├─ Uses nx:run-commands executor for execution
│       │   ├─ No declaration generation (composite: false, declaration: false)
│       │   ├─ Dependencies in devDependencies (not dependencies)
│       │   └─ **Guinea Pig Package**: Self-contained without shared dependencies, uses direct instantiation
│       │
│       └─ NO → Reconsider package purpose or consult team
```

### **Core Architectural Principles**

- **VSCode API Import Rules**:
    - **Core packages**: Use type imports only (`import type { Uri } from 'vscode'`)
    - **Extension packages**: Create local adapters with VSCode value imports
    - **No shared package usage**: Each package is completely self-contained
- **Direct VSCode imports**: Limited to types only for decoupling and complete injection
- **Thin Wrapper Extensions**: Extension packages contain only VSCode integration code
- **Business Logic in Core**: All business logic belongs in core packages, not extensions
- **Guinea Pig Package Principles**: Core packages should be self-contained without shared dependencies, using direct instantiation rather than DI containers
- **Local Interface Implementation**: Core packages define their own interfaces and adapters, no shared dependencies

## **Build System Architecture**

### **Core Package Build Configuration**

- **Executor**: `@nx/esbuild:esbuild`
- **Bundle**: `false` (library mode)
- **Format**: `["esm"]` (ES modules)
- **Declaration**: `true` with `declarationMap: true`
- **External Dependencies**: All runtime dependencies must be externalized
- **TypeScript Config**: Uses `tsconfig.lib.json` for build, `tsconfig.json` for IDE support

### **Extension Package Build Configuration**

- **Executor**: `@nx/esbuild:esbuild`
- **Bundle**: `true` (application mode)
- **Format**: `["cjs"]` (CommonJS for VSCode compatibility)
- **External Dependencies**: Only `vscode` and core package dependencies
- **Assets**: Include extension assets in build output
- **TypeScript Config**: Uses `tsconfig.json` with cross-project references

### **TypeScript Configuration Patterns**

#### **Core Package TypeScript Setup**

- **`tsconfig.json`**: IDE support with `composite: true`, references `tsconfig.lib.json`
- **`tsconfig.lib.json`**: Build configuration with unique output directories
- **Output Structure**:
    - `tsconfig.json`: `./out-tsc/tsconfig.tsbuildinfo`
    - `tsconfig.lib.json`: `./out-tsc/lib/tsconfig.lib.tsbuildinfo`
- **Declaration Generation**: `declaration: true`, `declarationMap: true`

#### **Extension Package TypeScript Setup**

- **`tsconfig.json`**: Single configuration with `composite: true`
- **Cross-Project References**: References core package for type checking
- **Declaration Only**: `emitDeclarationOnly: true` (no JS output from TypeScript)
- **Output**: `./dist` directory for build artifacts

### **Package.json Configuration**

#### **Core Package Package.json**

- **Type**: `"module"` (ES modules)
- **Main/Module**: Point to built output
- **Types**: Point to declaration files
- **Exports**: Proper module resolution
- **Dependencies**: Only runtime dependencies
- **DevDependencies**: Build and development tools

#### **Extension Package Package.json**

- **Type**: No `"type"` field (CommonJS)
- **Main**: Point to bundled output
- **Dependencies**: Core package and minimal runtime dependencies
- **DevDependencies**: Build tools and types
- **VSCode Configuration**: Complete extension manifest

## **Testing Architecture**

### **Test Configuration Pattern**

- **Executor**: `@nx/vite:test` (direct executor, not extends)
- **Dependency Chain**: `dependsOn: ["^build"]` for core packages
- **Test Organization**: `__tests__/functional/` structure
- **Setup Files**: `./__tests__/_setup.ts` for global test setup
- **Vitest Config**: Extends base functional config with project-specific setup

### **Test Target Configuration**

#### **Core Package Test Targets**

```json
"test": {
    "executor": "@nx/vite:test",
    "outputs": ["{options.reportsDirectory}"],
    "dependsOn": ["build", "^build"],
    "options": {}
},
"test:full": {
    "executor": "@nx/vite:test",
    "outputs": ["{options.reportsDirectory}"],
    "dependsOn": [
        {
            "dependencies": true,
            "target": "test",
            "params": "forward"
        }
    ],
    "options": {}
}
```

#### **Extension Package Test Targets**

- **Same pattern as core** but with extension-specific setup
- **Cross-project references** for testing extension with core dependencies
- **VSCode API mocking** through shared test utilities

### **Testing Strategy**

- **Comprehensive Testing Mandate**: Test suites MUST comprehensively cover all functionality to prevent unforeseen issues in the codebase
- **FORBIDDEN Setup Tests**: Never create "setup tests" that only verify imports, basic instantiation, or framework configuration
- **Functional Tests**: All main tests in `__tests__/functional/` directory OR `__tests__/` for adapter/service tests
- **Global Setup**: VSCode API mocking and common test utilities with comprehensive coverage
- **Mock Precision**: Test mocks must precisely match actual API signatures and parameter handling patterns
- **Mock Patterns**: Simple mock objects with Vitest's built-in capabilities
- **Test Isolation**: Clean test runs with no state leakage
- **Real Behavior Validation**: Test actual runtime behavior, not just mock replacements
- **Performance-Aware Testing**: Split large test files (500+ lines) proactively to prevent hanging and performance issues
- **Internal Method Mocking**: Mock complex internal methods (like `regenerateAndApplyTheme`) to prevent test timeouts and isolate unit tests
- **Standard VSCode Mocking**: Use `vi.mock('vscode')` for extension tests, not Mockly unless explicitly required
- **100% Success Requirement**: All tests must pass before considering testing complete
- **User Feedback Priority**: When user provides explicit testing guidance, immediately realign all testing efforts
- **Interface-First Testing**: Always analyze interface signatures before implementing adapters to prevent type errors
- **Constants over Assumptions**: Always check configuration files for actual values rather than guessing in tests
- **Incremental Test Validation**: Regular test execution during implementation prevents accumulated errors

## **Dependency Management**

### **Core Package Dependencies**

- **Runtime Dependencies**: Only essential business logic dependencies
- **External Dependencies**: All dependencies externalized in build config
- **No Shared Dependencies**: Self-contained without shared package dependencies
- **Direct Instantiation**: No DI containers, use direct service instantiation

### **Extension Package Dependencies**

- **Core Package**: Primary dependency on corresponding core package
- **VSCode Types**: `@types/vscode` in devDependencies
- **Minimal Runtime**: Only essential VSCode integration dependencies
- **Build Dependencies**: TypeScript, Vitest, and build tools in devDependencies

### **Externalization Strategy**

- **Core Packages**: Externalize all dependencies except internal business logic
- **Extension Packages**: Externalize `vscode` and core package dependencies
- **Build Configuration**: Explicit `external` array in esbuild configuration

## **Project.json Configuration Patterns**

### **Core Package Project.json**

```json
{
    "name": "@fux/{feature}-core",
    "projectType": "library",
    "targets": {
        "build": {
            "executor": "@nx/esbuild:esbuild",
            "options": {
                "main": "packages/{feature}/core/src/index.ts",
                "outputPath": "packages/{feature}/core/dist",
                "tsConfig": "packages/{feature}/core/tsconfig.lib.json",
                "format": ["esm"],
                "bundle": false,
                "external": ["vscode", "dependency1", "dependency2"]
            }
        },
        "test": {
            "executor": "@nx/vite:test",
            "dependsOn": ["^build"]
        }
    },
    "tags": ["core"]
}
```

### **Extension Package Project.json**

```json
{
    "name": "@fux/{feature}-ext",
    "projectType": "application",
    "targets": {
        "build": {
            "executor": "@nx/esbuild:esbuild",
            "dependsOn": ["^build"],
            "options": {
                "entryPoints": ["packages/{feature}/ext/src/extension.ts"],
                "outputPath": "packages/{feature}/ext/dist",
                "format": ["cjs"],
                "bundle": true,
                "external": ["vscode"],
                "assets": [
                    {
                        "glob": "**/*",
                        "input": "packages/{feature}/ext/assets/",
                        "output": "./assets/"
                    }
                ]
            }
        },
        "package": {
            "executor": "nx:run-commands",
            "dependsOn": ["build"],
            "options": {
                "command": "node scripts/create-vsix.js packages/{feature}/ext vsix_packages"
            }
        },
        "package:dev": {
            "executor": "nx:run-commands",
            "dependsOn": ["build"],
            "options": {
                "command": "node scripts/create-vsix.js packages/{feature}/ext vsix_packages --dev"
            }
        }
    },
    "tags": ["ext"]
}
```

## **Systematic Refactoring Protocols**

### **Architecture Refactoring Protocol**

When refactoring packages to align with new architectural guidelines:

1. **Documentation Update First**:
    - Update architectural documentation with critical requirements
    - Document preservation requirements for framework-specific configuration
2. **Interface-First Development**:
    - Define complete interface contracts before implementation
    - Create local interfaces to replace external dependencies
3. **Incremental Complexity Management**:
    - Start with simple, well-understood services
    - Establish patterns before tackling complex, interdependent components
4. **Test Infrastructure Foundation**:
    - Establish comprehensive testing infrastructure with proper mocking
    - Create mock functions for all local interfaces
5. **Systematic Error Resolution**:
    - Address interface completeness first
    - Fix type mismatches systematically
    - Update adapters to match interfaces
    - Verify build success before proceeding

### **Large-Scale Renaming Protocol**

When renaming packages, features, or commands across the entire codebase:

1. **Logical Order Execution**:
    - Directories → Package Names → Command IDs → Display Names → Configuration Files → Documentation
2. **Verification at Each Step**:
    - Run builds and tests after each phase to catch issues early
    - Update aliases and references immediately
3. **Comprehensive Coverage**:
    - All package.json files (name, dependencies, devDependencies)
    - All project.json files (name, paths, commands)
    - All source files (imports, exports, class names)
    - All test files (descriptions, mock names)
    - All documentation (README files, comments, examples)
    - All configuration files (nx.json, tsconfig files, vitest configs)

### **Architectural Feedback Integration**

When users provide feedback about testing or implementation issues:

1. **Treat as Architectural Revelation**: User feedback about testing flaws may reveal fundamental architectural problems
2. **Investigate Systemic Issues**: Don't fix surface-level problems without considering architectural implications
3. **Create Focused Integration Tests**: Validate actual runtime behavior, not just mock replacements
4. **Test Real Patterns**: Use integration tests to validate core architectural patterns before fixing individual issues
5. **User Preference Enforcement**: Strictly adhere to user's architectural preferences even when they conflict with initial assumptions

### **Pattern Alignment Protocol**

When implementing new features or refactoring existing code:

1. **Follow Established Patterns**: Use documented architectural approaches rather than creating custom solutions
2. **Test Structure Alignment**: Follow established project patterns for test organization and setup
3. **Architectural Compliance Verification**: Validate core architectural assumptions before addressing surface-level issues
4. **Documentation Consistency**: Ensure alignment with existing documentation and patterns

## **Critical Architectural Rules**

### **Adapter Architecture**

- **Rule**:
    - **Core packages**: Define interfaces only, no adapters
    - **Extension packages**: Create local adapters in `src/adapters/` that implement core interfaces
    - **No shared package usage**: Each package is self-contained
- **Rationale**:
    - Core packages remain pure business logic without VSCode dependencies
    - Extension packages handle VSCode integration through local adapters
    - Self-contained packages enable comprehensive testing and independent validation
- **Implementation**:
    - Core packages: Define interfaces in `src/_interfaces/`
    - Extension packages: Create adapters in `src/adapters/` with VSCode value imports
    - No dependencies on `@fux/shared` or other shared packages

### **VSCode Value Import Restrictions**

- **Rule**:
    - **Core packages**: NO VSCode value imports allowed, use `import type { Api } from 'vscode'` only
    - **Extension packages**: Create local adapters with VSCode value imports, no shared package usage
- **Rationale**:
    - Core packages maintain decoupling from VSCode API for comprehensive testing
    - Extension packages handle VSCode integration through local adapters
    - Self-contained packages enable independent testing and validation
- **Implementation**:
    - Core packages: `import type { Uri } from 'vscode'`
    - Extension packages: Create adapters in `src/adapters/` with VSCode value imports
    - No dependencies on `@fux/shared` or other shared packages

### **Dependency Management**

- **Rule**: Build-only dependencies must be in `devDependencies`
- **Rationale**: Prevents extraneous dependencies in production packages, reduces VSIX package size
- **Implementation**: Runtime dependencies in `dependencies`, build/development dependencies in `devDependencies`

### **Externalization Strategy**

- **Rule**: All third-party dependencies must be properly externalized
- **Rationale**: Ensures clean dependency management, prevents bundling issues
- **Implementation**: List all runtime dependencies in `external` array in build configuration

### **Node.js Module Import Restrictions**

- **Rule**: NO direct Node.js module imports in extension code
- **Rationale**: VSCode extensions should not include Node.js built-in modules as dependencies
- **Implementation**: Use VSCode's built-in file system API through workspace adapters

### **Shared Path Alias Resolution**

- **Rule**: TypeScript path alias for `@fux/shared` must point to package root (`libs/shared`), not `libs/shared/src`
- **Rationale**: Ensures consumers use referenced project's declaration output instead of inlining sources
- **Implementation**: Set path mapping to package root in consumer `tsconfig.lib.json`

### **Guinea Pig Package Architecture**

- **Rule**: Core packages must be self-contained without shared dependencies
- **Rationale**: Enables independent testing and validation of core logic
- **Implementation**: Use direct service instantiation, not DI containers; mock all external dependencies in tests
- **Local Interface Pattern**: Core packages define their own interfaces (e.g., `IUri`, `IUriFactory`) to replace VSCode value usage
- **Reasonable Dependencies**: Services should have reasonable dependencies based on functionality, not excessive dependencies (9+)

### **VSCode Extension Configuration Preservation**

- **Rule**: ALWAYS preserve all VSCode extension configuration when refactoring extension packages
- **Rationale**: VSCode extension functionality depends on `contributes`, `activationEvents`, `engines`, and other metadata
- **Implementation**: Only remove business logic dependencies, never remove VSCode-specific configuration sections
- **CRITICAL**: This is non-negotiable - removing VSCode configuration breaks extension functionality

### **TypeScript Project References**

- **Rule**: Core packages must use proper project references with unique output directories
- **Rationale**: Prevents build info conflicts and enables proper incremental builds
- **Implementation**:
    - `tsconfig.json`: `./out-tsc/tsconfig.tsbuildinfo`
    - `tsconfig.lib.json`: `./out-tsc/lib/tsconfig.lib.tsbuildinfo`

### **Test Configuration Consistency**

- **Rule**: All packages must use direct `@nx/vite:test` executor, not extends
- **Rationale**: Ensures consistent test execution and prevents configuration conflicts
- **Implementation**: Explicit executor configuration in project.json test targets

### **Comprehensive Testing Architecture**

- **Rule**:
    - **Core packages**: Test business logic in complete isolation without VSCode dependencies
    - **Extension packages**: Test VSCode integration through local adapters
    - **No shared package testing**: Each package tests its own functionality independently
- **Rationale**:
    - Core packages can be tested without complex VSCode mocking
    - Extension packages test real VSCode integration patterns
    - Self-contained testing enables deep validation and fast execution
- **Implementation**:
    - Core packages: Mock all external dependencies, test pure business logic
    - Extension packages: Test adapters with VSCode API mocks, validate integration flows
    - Independent test suites enable comprehensive coverage and regression prevention
- **Mock Precision**: Test mocks must precisely match actual API signatures and parameter handling patterns
- **Real Behavior Validation**: Tests must validate actual runtime behavior, not just mock replacements
- **Performance-Aware Testing**: Split large test files (500+ lines) proactively to prevent hanging and performance issues

### **VS Code Extension Integration Testing**

- **Rule**: VS Code extension integration tests require specific environment configuration to prevent UI operations from hanging
- **Critical Requirements**:
    - **Environment Variable**: Always set `VSCODE_TEST: '1'` in `.vscode-test.mjs` configuration
    - **Setup Files**: Use `setupFiles` configuration option instead of `--require` parameter for module loading
    - **Environment Detection**: Extensions must detect test environment with `process.env.VSCODE_TEST === '1'`
    - **UI Operation Handling**: Skip UI operations (like `window.showInformationMessage()`) in test environment
- **Rationale**:
    - Missing `VSCODE_TEST` environment variable causes UI operations to hang indefinitely in test context
    - `--require` parameter can cause module resolution issues in extension host context
    - Test environment detection prevents extension from attempting UI operations that block test execution
- **Implementation**:
    - Configure `.vscode-test.mjs` with `env: { VSCODE_TEST: '1' }` and `setupFiles: ['./out-tsc/suite/index.js']`
    - Use `const IS_TEST_ENVIRONMENT = process.env.VSCODE_TEST === '1'` in extension code
    - Conditionally skip UI operations: `if (!IS_TEST_ENVIRONMENT) { await window.showInformationMessage(...) }`
    - Throw errors in test environment for proper test failure reporting

## **Development Workflow**

### **Pre-Development Setup**

1. **Check file organization** - understand current project structure
2. **Verify documentation** - consult SOP.md and FocusedUX-Testing-Strategy.md
3. **Identify dependencies** - map affected components and consumers
4. **Plan system-wide impact** - account for all related changes

### **During Development**

1. **Follow established patterns** - use documented architectural approaches
2. **Update all consumers** - shared adapters, imports, DI wiring, TypeScript mappings
3. **Maintain consistency** - apply changes uniformly across affected components
4. **Document as you go** - update Actions Log and relevant documentation

### **Post-Development Verification**

1. **Run quality gates** - builds, tests, linters, type checks
2. **Verify system-wide impact** - ensure all consumers are updated
3. **Update documentation** - Actions Log, testing strategies, architectural patterns
4. **Validate end-to-end** - ensure primary workflows still function
5. **MANDATORY DATE VERIFICATION**:
    - [ ] Date verification command executed for any Actions Log entries
    - [ ] Actual file modification timestamps used (no estimated dates)
    - [ ] All timestamps match file system reality

## **Quality Assurance**

### **Build Verification**

- **Always run `{alias} b` first** - ensure clean builds before testing
- **Fix build errors immediately** - don't proceed with broken builds
- **Use `--skip-nx-cache` for troubleshooting** - bypass cache when diagnosing issues

### **Test Execution**

- **Full test suites** - run complete tests to ensure no regressions
- **Test isolation** - ensure tests don't interfere with each other
- **Mock validation** - verify mocks properly simulate real behavior
- **Performance measurement** - before/after metrics for optimizations

### **Test Lanes**

- **`t`**: Project tests only (no coverage) - fast feedback
- **`tc`/`tcw`**: Tests with coverage - comprehensive validation
- **Build-before-test**: Enabled via Nx target defaults with cache
- **Avoid `-s` unless diagnosing cache issues**

### **Nx Test Output Behavior**

- **Default suppression**: Nx shows only summary of dependent tasks
- **`--stream`**: See task-specific outputs from all dependent packages
- **`--verbose`**: Deep internal debugging (use sparingly)
- **Dependency count**: "X tasks it depends on" = build dependencies, not test dependencies
- **Cache-bypass diagnosis**: Use `--skip-nx-cache` to distinguish execution vs output suppression

## **Command Execution & Tooling**

### **Aka Alias Mandate**

- **ALWAYS use `aka` aliases** for all project operations
- **NEVER fall back to npm/nx directly** unless explicitly requested
- **Primary discovery**: `aka help` or `aka list`
- **Fallback discovery**: `.vscode/shell/pnpm_aliases.json`, `Show-PnpmAliases`, `libs/tools/aka/README.md`
- **Deviation prevention**: Any deviation constitutes a critical failure

### **Build Tool Preferences**

- **Use `--skip-nx-cache`** for troubleshooting Nx build issues
- **Prefer `pnpm` over `npm`** for all package management tasks
- **Use project-specific aliases** - `shared`, `mockly`, `pbc`, `pbe`, etc.

### **PowerShell Profile Setup**

- **CRITICAL**: At session start, verify profile loading and alias availability
- **Test both native and alias commands** when troubleshooting:
    ```powershell
    # Example: Test both native and alias versions
    pnpm run build --filter=ghost-writer
    gw b
    ```
- **FAILURE RECOVERY**: If profile loading fails, halt operations and report before proceeding

## **Shared Adapter Change Protocol**

### **When Modifying Shared Components**

1. **Identify all consumers** - imports, DI wiring, TypeScript mappings
2. **Update all affected packages** within the same session
3. **Verify TypeScript path mappings** for `@fux/shared` across projects
4. **Run `nh tsc` and auditor** - fix any fallout immediately

### **Required Updates**

- **Import statements** - update all packages using the modified adapter
- **DI container wiring** - update injection configurations
- **TypeScript mappings** - verify `@fux/shared` path resolution
- **Test mocks** - update any test files using the adapter

## **Common Build Issues**

### **TypeScript Declaration Errors**

- Ensure core packages have `declaration: true` and `declarationMap: true` in `tsconfig.lib.json`
- Verify proper `references` and `emitDeclarationOnly: true` in `tsconfig.json`

### **Bundle Size Issues**

- Check for unnecessary dependencies (like TypeScript AST usage)
- Consider individual exports for better tree-shaking
- Use proper externalization strategy

### **Import Resolution Errors**

- Verify `tsconfig.json` has proper `references` and `emitDeclarationOnly: true`
- Check path mappings in `tsconfig.base.json` and individual package configs
- Ensure all `@fux/*` packages have proper path mappings

### **Path Sanitization Issues**

- `PathUtilsAdapter.santizePath()` is designed for filenames only, not full file paths
- Always sanitize individual components before joining paths
- Avoid drive letter corruption by not sanitizing complete file paths

### **Package.json Module Type Mismatch**

- Remove `"type": "module"` from extension package `package.json` when using CommonJS build format
- Ensure build configuration format matches package.json module type

### **TypeScript Build Info Conflicts**

- **Rule**: Each TypeScript configuration must have unique output directories
- **Core Package Fix**:
    - `tsconfig.json`: `./out-tsc/tsconfig.tsbuildinfo`
    - `tsconfig.lib.json`: `./out-tsc/lib/tsconfig.lib.tsbuildinfo`
- **Extension Package**: Single `tsconfig.json` with `./dist` output

## **Documentation Standards**

### **Actions Log Requirements**

- **Entry gating**: Only add entries when:
    - `retro` command issued
    - Issue explicitly resolved
    - Explicit request to add entry
- **MANDATORY sections**: "What Was Tried and Failed" documenting all failed attempts
- **Post-change documentation**: Update in same session as implementation
- \*\*System.Collections.Hashtable[0]

### **Date Verification Priority Protocol**

**Priority Order for Date Retrieval:**

1. **Modified Files Only**: Start by running .\scripts\Get-FileStats.ps1 -FilePaths @("file1.ts", "file2.js", "file3.json") on only the files that were actually modified during the session
2. **Project Directory**: If modified files cannot be determined, run .\scripts\Get-FileStats.ps1 -Directories @("packages/project-name") on the specific project(s) worked on
3. **User Input**: If neither modified files nor project scope can be determined systematically, **ASK THE USER** for the date and time to be used

**❌ FORBIDDEN Actions:**

- **NEVER use placeholders**: No "today", "recently", or estimated dates
- **NEVER create random dates**: No guessing or making up timestamps
- **NEVER skip verification**: Always attempt systematic date retrieval first
- **NEVER use current system time**: Use actual file modification times, not when the script runs

**CRITICAL**: If systematic date retrieval fails, the user must provide the exact date and time to be used as the final fallback.

- **CRITICAL**: If you skip this verification step, you are violating the protocol and must correct immediately
- **Date Format**: Use exact timestamp returned: `YYYY-MM-DD HH:MM:SS`

### **Testing Strategy Updates**

- **Update `docs/FocusedUX-Testing-Strategy.md`** for test-related fixes
- **Update package-specific strategies** in `__tests__/TESTING_STRATEGY.md`
- **Document new patterns** and anti-patterns discovered
- **Real Pattern Validation**: Always test actual runtime behavior, not just mock replacements
- **Integration Test First**: Create focused integration tests to validate core architectural patterns before fixing individual test failures
- **Systematic Validation**: Validate core architectural assumptions before addressing surface-level issues

### **SOP Documentation Updates**

- **Update `docs/SOP.md`** for architectural changes, build system modifications, or new patterns
- **Review SOP references** to ensure cross-document consistency
- **Update package structure** or build configurations when changes occur
- **Document new troubleshooting patterns** or common issues discovered

### **Project Rules**

- **Keep project-specific rules** in this file
- **Update based on lessons learned** from Actions Log entries
- **Maintain consistency** with Universal Doctrine principles

## **Auditor Behavior & Ergonomics**

### **Canonical Configuration**

- **Minimal enforcement** - only essential keys (avoid `rootDir` unless required)
- **Warn-only mode** - surface issues without failing developer workflows
- **False positive prevention** - avoid enforcing non-essential keys across heterogeneous projects
- **Template co-location** - configuration templates must be within the tool package that validates them
- **ES module compatibility** - use `fileURLToPath(import.meta.url)` for file path resolution in tools

### **Validation Approach**

- **Essential checks only** - focus on critical architectural violations
- **Advisory warnings** - provide guidance without blocking development
- **Context-aware validation** - consider project-specific requirements

## **Common Workflows**

### **Adding New Package**

1. **Use Nx generators** - follow established project patterns
2. **Update shared adapters** - if new VSCode APIs are needed
3. **Configure testing** - follow FocusedUX Testing Strategy patterns
4. **Update documentation** - Actions Log, testing strategies
5. **Verify system-wide** - ensure all consumers are updated

### **Modifying Existing Package**

1. **Check dependencies** - identify all affected components
2. **Follow architectural patterns** - consult SOP.md and FocusedUX-Testing-Strategy.md
3. **Update all consumers** - imports, DI wiring, TypeScript mappings
4. **Run quality gates** - builds, tests, linters, type checks
5. **Document changes** - Actions Log with lessons learned

### **Troubleshooting Issues**

1. **Use cache bypass** - `--skip-nx-cache` for diagnosis
2. **Check documentation** - consult established patterns first
3. **Verify assumptions** - test against actual system behavior
4. **Document solutions** - update Actions Log with new patterns

### **Test Failure Resolution Protocol**

1. **Run tests** - identify specific failure patterns and error messages
2. **Analyze implementation** - understand actual method signatures, parameter patterns, and behavior
3. **Fix mocks/expectations** - align mock behavior with real implementation details
4. **Iterate until success** - repeat the cycle until 100% test success is achieved
5. **Document learnings** - capture new patterns and anti-patterns discovered

## **Anti-Patterns**

### **❌ FORBIDDEN: Architectural Violations**

- Business logic in extension packages
- Direct VSCode value imports outside shared adapters
- Incomplete consumer updates when modifying shared components
- Skipping quality gates for expediency
- **DI Containers in Guinea Pig Packages**: Never use DI containers in core packages that should be self-contained
- **Custom Test Organization**: Don't create custom test structures when established patterns exist
- **Shared Dependencies in Core Packages**: Never add shared package dependencies to core packages
- **VSCode Extension Configuration Removal**: NEVER remove `contributes`, `activationEvents`, `engines`, or other VSCode extension metadata when refactoring

### **❌ FORBIDDEN: Testing Violations**

- Using `vi.mock('vscode')` in shared package tests
- Skipping tests to meet deadlines
- Incomplete mock implementations
- Performance regressions without measurement
- **Bypassing DI Container in Tests**: Never mock the entire DI container - test actual injection patterns
- **Complex Mock Hierarchies**: Avoid elaborate mock setups that compete with real production patterns
- **Ignoring User Testing Insights**: When user identifies testing flaws, investigate architectural implications
- **Surface-Level Problem Fixing**: Don't fix individual test failures without considering systemic architectural issues
- **Large Test File Anti-Pattern**: Never allow test files to exceed 500 lines - split into focused units proactively
- **Architectural Assumption Violations**: Never assume modern packages use specific mocking strategies without user confirmation
- **Timeout-Inducing Tests**: Never create tests that call complex internal methods without mocking them to prevent timeouts
- **Test Simplification Anti-Pattern**: Never simplify tests to the point where they don't verify actual implementation behavior - this defeats regression testing
- **Mock Parameter Mismatches**: Never write mock expectations without understanding actual method signatures, parameter counts, and behavior patterns
- **Service Lifecycle Testing Neglect**: Never test service disposal without first initializing the service to set up disposables
- **Configuration Mocking Oversimplification**: Never underestimate the complexity of mocking platform-specific configuration systems
- **Dynamic Import Violations**: Never use `await import()` for mocking in test files - use static imports with `vi.mocked()`
- **Redundant Mocking**: Never create redundant mocks when standard Vitest mocking patterns are sufficient
- **VS Code Integration Test Environment Violations**: Never skip `VSCODE_TEST='1'` environment variable in `.vscode-test.mjs` configuration
- **UI Operation Test Violations**: Never allow UI operations (like `window.showInformationMessage()`) to execute in test environment without environment detection
- **Module Loading Anti-Pattern**: Never use `--require` parameter when `setupFiles` configuration option is available for VS Code extension tests

### **❌ FORBIDDEN: Documentation Violations**

- Skipping Actions Log updates for significant changes
- Missing "What Was Tried and Failed" sections
- Incomplete consumer documentation
- Outdated testing strategies
- **Skipping Date Verification**: NEVER write Actions Log entries without verifying actual file modification timestamps
- **Making Up Dates**: NEVER use estimated or guessed dates - always use verified file timestamps
- **Ignoring Date Guidelines**: NEVER ignore explicit date handling requirements in documentation protocols
- **Premature Completion Claims**: NEVER document completion without verification of ALL claimed components

### **❌ FORBIDDEN: Build Violations**

- Build-only dependencies in `dependencies` instead of `devDependencies`
- Direct Node.js module imports in extension code
- Missing externalization of third-party dependencies
- Incorrect TypeScript path mappings
- **Caching Packaging Targets**: NEVER cache `package:dev` targets - they create unique timestamped versions
- **Modifying Working Scripts**: NEVER modify working packaging scripts without clear evidence they're the problem
- **Missing .vscodeignore Files**: ALWAYS include `.vscodeignore` files for extensions that need `node_modules` inclusion
- **TypeScript Build Info Conflicts**: NEVER use overlapping output directories for different TypeScript configurations
- **Test Configuration Extends**: NEVER use `extends: "test"` in project.json - use direct executor configuration

### **❌ FORBIDDEN: Validation Violations**

- **Strict Error Throwing**: NEVER throw errors for non-critical validation issues - use warnings instead
- **User Experience Neglect**: NEVER prioritize strict validation over user experience for non-blocking issues
- **Phantom Dependency Assumptions**: NEVER assume phantom dependencies are the root cause without verification

### **❌ FORBIDDEN: Tool Configuration Violations**

- Hardcoded configuration templates in validation logic
- Templates placed outside the tool package that uses them
- CommonJS path resolution patterns in ES module tools
- Skipping incremental validation of file loading implementations

### **❌ FORBIDDEN: Refactoring Violations**

- **Incremental Renaming**: Never rename components partially - execute complete renaming in logical order
- **Pattern Deviation**: Don't create custom solutions when established patterns exist
- **Architectural Assumption Ignorance**: Never ignore user feedback about testing flaws - investigate architectural implications
- **Real Behavior Bypass**: Never test only mock replacements without validating actual runtime behavior
- **Interface-First Violations**: Never implement services before defining complete interface contracts
- **Complex Component Refactoring**: Never refactor complex, interdependent components before establishing patterns with simple components
- **Build-Before-Interface**: Never attempt to build before completing interface definitions and architectural refactoring

## **Critical Communication Protocols**

### **Question vs Directive Distinction**

**CRITICAL RULE**: Distinguish between user questions seeking understanding and directives requiring action.

#### **Questions Seeking Understanding**

When the user asks questions like:

- "Why are we creating adapters in ext and not in core?"
- "Shouldn't the tests be using \_setup instead of standalone mock files?"
- "Why did you think that was the right approach?"
- "What caused you to believe/think that?"

**RESPONSE PROTOCOL**:

- **Explain the rationale** behind the current approach
- **Share the architectural reasoning** and design decisions
- **Educate on the patterns** and why they exist
- **DO NOT take action** unless explicitly requested
- **Treat as learning opportunities** for both parties

#### **Directives Requiring Action**

When the user uses directive language like:

- "We need to do X"
- "You need to implement Y"
- "We should change Z"
- "Move this to that location"

**RESPONSE PROTOCOL**:

- **Confirm understanding** of the request
- **Validate against best practices** and project documentation
- **Suggest improvements** if the directive conflicts with established patterns
- **Propose better approaches** if the idea is good but implementation could be improved
- **Execute immediately** if the directive aligns with project standards

#### **Mentorship Role Recognition**

- **User is learning** and seeking understanding of architectural decisions
- **Agent is mentor** with expertise in best practices and project patterns
- **Collaborative relationship** where both parties contribute to better solutions
- **User may have good ideas with suboptimal implementation approaches**
- **Agent should guide toward better implementations** while respecting user's intent

#### **Implementation Guidelines**

- **Questions**: Provide educational explanations, don't take action
- **Directives**: Validate, suggest improvements if needed, then execute
- **Always consider**: Industry best practices, project documentation, architectural consistency
- **Be transparent**: If a directive conflicts with established patterns, explain why and suggest alternatives
- **Maintain trust**: User's suggestions are valuable input, even if implementation needs refinement

#### **Tool Execution Context Awareness**

- **Output Handling Differences**: Tool execution may handle script output differently than direct terminal execution
- **Verification Required**: Always verify script output when using tool execution, especially for scripts that return objects
- **Fallback Strategy**: If tool execution produces unexpected results, test the same command directly in terminal
- **Profile Loading**: FUX profile loads correctly in both contexts, but output processing may differ
- **Known Limitation**: Some scripts may behave differently in tool execution context vs direct terminal execution

> **Note:** This document contains FocusedUX-specific operational guidelines. For universal AI behavior protocols, refer to Universal-Operational-Doctrine.mdc. For detailed build system and architectural patterns, refer to docs/SOP.md.

> **Note:** This document contains FocusedUX-specific operational guidelines. For universal AI behavior protocols, refer to Universal-Operational-Doctrine.mdc. For detailed build system and architectural patterns, refer to docs/SOP.md.

# FocusedUX Operational Doctrine

## **Project Architecture**

### **File Organization**

- **Packages**: `packages/` directory (extensions, core packages)
- **Libraries**: `libs/` directory (shared, mockly, tools)
- **Documentation**: `docs/` directory (strategies, logs, SOPs)
- **Configuration**: Root-level configs (`.cursor/rules/`, `nx.json`, etc.)

### **Package Archetypes**

- **`shared` (Library)**: Located in `libs/shared/`, contains shared services and abstractions for runtime use by other packages
- **`core` (Library)**: Located in `packages/{feature}/core/`, contains feature's abstract business logic, built to be tree-shakeable
- **`ext` (Application)**: Located in `packages/{feature}/ext/`, contains VSCode extension implementation, depends on core package
- **`tool` (Utility)**: Located in `libs/tools/{tool-name}/`, contains standalone utilities that run directly with tsx (no build step)

### **Package Structure Decision Tree**

```
Is the package intended to be a VS Code extension?
├─ YES → Use core/ext pattern (packages/{feature}/core + packages/{feature}/ext)
│   ├─ core: Library with business logic, built with @nx/esbuild:esbuild (bundle: false)
│   └─ ext: Application bundle, built with @nx/esbuild:esbuild (bundle: true)
│
├─ NO → Is the package a shared library consumed by other packages?
│   ├─ YES → Use shared pattern (libs/shared)
│   │   └─ Built with @nx/esbuild:esbuild (bundle: false), generates declarations
│   │
│   └─ NO → Is the package a standalone tool/utility that runs directly?
│       ├─ YES → Use tool pattern (libs/tools/{tool-name})
│       │   ├─ Runs directly with tsx (no build step)
│       │   ├─ Uses nx:run-commands executor for execution
│       │   ├─ No declaration generation (composite: false, declaration: false)
│       │   ├─ Dependencies in devDependencies (not dependencies)
│       │   └─ **Guinea Pig Package**: Self-contained without shared dependencies, uses direct instantiation
│       │
│       └─ NO → Reconsider package purpose or consult team
```

### **Core Architectural Principles**

- **VSCode API Import Rules**:
    - **Core packages**: Use type imports only (`import type { Uri } from 'vscode'`)
    - **Extension packages**: Create local adapters with VSCode value imports
    - **No shared package usage**: Each package is completely self-contained
- **Direct VSCode imports**: Limited to types only for decoupling and complete injection
- **Thin Wrapper Extensions**: Extension packages contain only VSCode integration code
- **Business Logic in Core**: All business logic belongs in core packages, not extensions
- **Guinea Pig Package Principles**: Core packages should be self-contained without shared dependencies, using direct instantiation rather than DI containers
- **Local Interface Implementation**: Core packages define their own interfaces and adapters, no shared dependencies

## **Build System Architecture**

### **Core Package Build Configuration**

- **Executor**: `@nx/esbuild:esbuild`
- **Bundle**: `false` (library mode)
- **Format**: `["esm"]` (ES modules)
- **Declaration**: `true` with `declarationMap: true`
- **External Dependencies**: All runtime dependencies must be externalized
- **TypeScript Config**: Uses `tsconfig.lib.json` for build, `tsconfig.json` for IDE support

### **Extension Package Build Configuration**

- **Executor**: `@nx/esbuild:esbuild`
- **Bundle**: `true` (application mode)
- **Format**: `["cjs"]` (CommonJS for VSCode compatibility)
- **External Dependencies**: Only `vscode` and core package dependencies
- **Assets**: Include extension assets in build output
- **TypeScript Config**: Uses `tsconfig.json` with cross-project references

### **TypeScript Configuration Patterns**

#### **Core Package TypeScript Setup**

- **`tsconfig.json`**: IDE support with `composite: true`, references `tsconfig.lib.json`
- **`tsconfig.lib.json`**: Build configuration with unique output directories
- **Output Structure**:
    - `tsconfig.json`: `./out-tsc/tsconfig.tsbuildinfo`
    - `tsconfig.lib.json`: `./out-tsc/lib/tsconfig.lib.tsbuildinfo`
- **Declaration Generation**: `declaration: true`, `declarationMap: true`

#### **Extension Package TypeScript Setup**

- **`tsconfig.json`**: Single configuration with `composite: true`
- **Cross-Project References**: References core package for type checking
- **Declaration Only**: `emitDeclarationOnly: true` (no JS output from TypeScript)
- **Output**: `./dist` directory for build artifacts

### **Package.json Configuration**

#### **Core Package Package.json**

- **Type**: `"module"` (ES modules)
- **Main/Module**: Point to built output
- **Types**: Point to declaration files
- **Exports**: Proper module resolution
- **Dependencies**: Only runtime dependencies
- **DevDependencies**: Build and development tools

#### **Extension Package Package.json**

- **Type**: No `"type"` field (CommonJS)
- **Main**: Point to bundled output
- **Dependencies**: Core package and minimal runtime dependencies
- **DevDependencies**: Build tools and types
- **VSCode Configuration**: Complete extension manifest

## **Testing Architecture**

### **Test Configuration Pattern**

- **Executor**: `@nx/vite:test` (direct executor, not extends)
- **Dependency Chain**: `dependsOn: ["^build"]` for core packages
- **Test Organization**: `__tests__/functional/` structure
- **Setup Files**: `./__tests__/_setup.ts` for global test setup
- **Vitest Config**: Extends base functional config with project-specific setup

### **Test Target Configuration**

#### **Core Package Test Targets**

```json
"test": {
    "executor": "@nx/vite:test",
    "outputs": ["{options.reportsDirectory}"],
    "dependsOn": ["build", "^build"],
    "options": {}
},
"test:full": {
    "executor": "@nx/vite:test",
    "outputs": ["{options.reportsDirectory}"],
    "dependsOn": [
        {
            "dependencies": true,
            "target": "test",
            "params": "forward"
        }
    ],
    "options": {}
}
```

#### **Extension Package Test Targets**

- **Same pattern as core** but with extension-specific setup
- **Cross-project references** for testing extension with core dependencies
- **VSCode API mocking** through shared test utilities

### **Testing Strategy**

- **Comprehensive Testing Mandate**: Test suites MUST comprehensively cover all functionality to prevent unforeseen issues in the codebase
- **FORBIDDEN Setup Tests**: Never create "setup tests" that only verify imports, basic instantiation, or framework configuration
- **Functional Tests**: All main tests in `__tests__/functional/` directory OR `__tests__/` for adapter/service tests
- **Global Setup**: VSCode API mocking and common test utilities with comprehensive coverage
- **Mock Precision**: Test mocks must precisely match actual API signatures and parameter handling patterns
- **Mock Patterns**: Simple mock objects with Vitest's built-in capabilities
- **Test Isolation**: Clean test runs with no state leakage
- **Real Behavior Validation**: Test actual runtime behavior, not just mock replacements
- **Performance-Aware Testing**: Split large test files (500+ lines) proactively to prevent hanging and performance issues
- **Internal Method Mocking**: Mock complex internal methods (like `regenerateAndApplyTheme`) to prevent test timeouts and isolate unit tests
- **Standard VSCode Mocking**: Use `vi.mock('vscode')` for extension tests, not Mockly unless explicitly required
- **100% Success Requirement**: All tests must pass before considering testing complete
- **User Feedback Priority**: When user provides explicit testing guidance, immediately realign all testing efforts
- **Interface-First Testing**: Always analyze interface signatures before implementing adapters to prevent type errors
- **Constants over Assumptions**: Always check configuration files for actual values rather than guessing in tests
- **Incremental Test Validation**: Regular test execution during implementation prevents accumulated errors

## **Dependency Management**

### **Core Package Dependencies**

- **Runtime Dependencies**: Only essential business logic dependencies
- **External Dependencies**: All dependencies externalized in build config
- **No Shared Dependencies**: Self-contained without shared package dependencies
- **Direct Instantiation**: No DI containers, use direct service instantiation

### **Extension Package Dependencies**

- **Core Package**: Primary dependency on corresponding core package
- **VSCode Types**: `@types/vscode` in devDependencies
- **Minimal Runtime**: Only essential VSCode integration dependencies
- **Build Dependencies**: TypeScript, Vitest, and build tools in devDependencies

### **Externalization Strategy**

- **Core Packages**: Externalize all dependencies except internal business logic
- **Extension Packages**: Externalize `vscode` and core package dependencies
- **Build Configuration**: Explicit `external` array in esbuild configuration

## **Project.json Configuration Patterns**

### **Core Package Project.json**

```json
{
    "name": "@fux/{feature}-core",
    "projectType": "library",
    "targets": {
        "build": {
            "executor": "@nx/esbuild:esbuild",
            "options": {
                "main": "packages/{feature}/core/src/index.ts",
                "outputPath": "packages/{feature}/core/dist",
                "tsConfig": "packages/{feature}/core/tsconfig.lib.json",
                "format": ["esm"],
                "bundle": false,
                "external": ["vscode", "dependency1", "dependency2"]
            }
        },
        "test": {
            "executor": "@nx/vite:test",
            "dependsOn": ["^build"]
        }
    },
    "tags": ["core"]
}
```

### **Extension Package Project.json**

```json
{
    "name": "@fux/{feature}-ext",
    "projectType": "application",
    "targets": {
        "build": {
            "executor": "@nx/esbuild:esbuild",
            "dependsOn": ["^build"],
            "options": {
                "entryPoints": ["packages/{feature}/ext/src/extension.ts"],
                "outputPath": "packages/{feature}/ext/dist",
                "format": ["cjs"],
                "bundle": true,
                "external": ["vscode"],
                "assets": [
                    {
                        "glob": "**/*",
                        "input": "packages/{feature}/ext/assets/",
                        "output": "./assets/"
                    }
                ]
            }
        },
        "package": {
            "executor": "nx:run-commands",
            "dependsOn": ["build"],
            "options": {
                "command": "node scripts/create-vsix.js packages/{feature}/ext vsix_packages"
            }
        },
        "package:dev": {
            "executor": "nx:run-commands",
            "dependsOn": ["build"],
            "options": {
                "command": "node scripts/create-vsix.js packages/{feature}/ext vsix_packages --dev"
            }
        }
    },
    "tags": ["ext"]
}
```

## **Systematic Refactoring Protocols**

### **Architecture Refactoring Protocol**

When refactoring packages to align with new architectural guidelines:

1. **Documentation Update First**:
    - Update architectural documentation with critical requirements
    - Document preservation requirements for framework-specific configuration
2. **Interface-First Development**:
    - Define complete interface contracts before implementation
    - Create local interfaces to replace external dependencies
3. **Incremental Complexity Management**:
    - Start with simple, well-understood services
    - Establish patterns before tackling complex, interdependent components
4. **Test Infrastructure Foundation**:
    - Establish comprehensive testing infrastructure with proper mocking
    - Create mock functions for all local interfaces
5. **Systematic Error Resolution**:
    - Address interface completeness first
    - Fix type mismatches systematically
    - Update adapters to match interfaces
    - Verify build success before proceeding

### **Large-Scale Renaming Protocol**

When renaming packages, features, or commands across the entire codebase:

1. **Logical Order Execution**:
    - Directories → Package Names → Command IDs → Display Names → Configuration Files → Documentation
2. **Verification at Each Step**:
    - Run builds and tests after each phase to catch issues early
    - Update aliases and references immediately
3. **Comprehensive Coverage**:
    - All package.json files (name, dependencies, devDependencies)
    - All project.json files (name, paths, commands)
    - All source files (imports, exports, class names)
    - All test files (descriptions, mock names)
    - All documentation (README files, comments, examples)
    - All configuration files (nx.json, tsconfig files, vitest configs)

### **Architectural Feedback Integration**

When users provide feedback about testing or implementation issues:

1. **Treat as Architectural Revelation**: User feedback about testing flaws may reveal fundamental architectural problems
2. **Investigate Systemic Issues**: Don't fix surface-level problems without considering architectural implications
3. **Create Focused Integration Tests**: Validate actual runtime behavior, not just mock replacements
4. **Test Real Patterns**: Use integration tests to validate core architectural patterns before fixing individual issues
5. **User Preference Enforcement**: Strictly adhere to user's architectural preferences even when they conflict with initial assumptions

### **Pattern Alignment Protocol**

When implementing new features or refactoring existing code:

1. **Follow Established Patterns**: Use documented architectural approaches rather than creating custom solutions
2. **Test Structure Alignment**: Follow established project patterns for test organization and setup
3. **Architectural Compliance Verification**: Validate core architectural assumptions before addressing surface-level issues
4. **Documentation Consistency**: Ensure alignment with existing documentation and patterns

## **Critical Architectural Rules**

### **Adapter Architecture**

- **Rule**:
    - **Core packages**: Define interfaces only, no adapters
    - **Extension packages**: Create local adapters in `src/adapters/` that implement core interfaces
    - **No shared package usage**: Each package is self-contained
- **Rationale**:
    - Core packages remain pure business logic without VSCode dependencies
    - Extension packages handle VSCode integration through local adapters
    - Self-contained packages enable comprehensive testing and independent validation
- **Implementation**:
    - Core packages: Define interfaces in `src/_interfaces/`
    - Extension packages: Create adapters in `src/adapters/` with VSCode value imports
    - No dependencies on `@fux/shared` or other shared packages

### **VSCode Value Import Restrictions**

- **Rule**:
    - **Core packages**: NO VSCode value imports allowed, use `import type { Api } from 'vscode'` only
    - **Extension packages**: Create local adapters with VSCode value imports, no shared package usage
- **Rationale**:
    - Core packages maintain decoupling from VSCode API for comprehensive testing
    - Extension packages handle VSCode integration through local adapters
    - Self-contained packages enable independent testing and validation
- **Implementation**:
    - Core packages: `import type { Uri } from 'vscode'`
    - Extension packages: Create adapters in `src/adapters/` with VSCode value imports
    - No dependencies on `@fux/shared` or other shared packages

### **Dependency Management**

- **Rule**: Build-only dependencies must be in `devDependencies`
- **Rationale**: Prevents extraneous dependencies in production packages, reduces VSIX package size
- **Implementation**: Runtime dependencies in `dependencies`, build/development dependencies in `devDependencies`

### **Externalization Strategy**

- **Rule**: All third-party dependencies must be properly externalized
- **Rationale**: Ensures clean dependency management, prevents bundling issues
- **Implementation**: List all runtime dependencies in `external` array in build configuration

### **Node.js Module Import Restrictions**

- **Rule**: NO direct Node.js module imports in extension code
- **Rationale**: VSCode extensions should not include Node.js built-in modules as dependencies
- **Implementation**: Use VSCode's built-in file system API through workspace adapters

### **Shared Path Alias Resolution**

- **Rule**: TypeScript path alias for `@fux/shared` must point to package root (`libs/shared`), not `libs/shared/src`
- **Rationale**: Ensures consumers use referenced project's declaration output instead of inlining sources
- **Implementation**: Set path mapping to package root in consumer `tsconfig.lib.json`

### **Guinea Pig Package Architecture**

- **Rule**: Core packages must be self-contained without shared dependencies
- **Rationale**: Enables independent testing and validation of core logic
- **Implementation**: Use direct service instantiation, not DI containers; mock all external dependencies in tests
- **Local Interface Pattern**: Core packages define their own interfaces (e.g., `IUri`, `IUriFactory`) to replace VSCode value usage
- **Reasonable Dependencies**: Services should have reasonable dependencies based on functionality, not excessive dependencies (9+)

### **VSCode Extension Configuration Preservation**

- **Rule**: ALWAYS preserve all VSCode extension configuration when refactoring extension packages
- **Rationale**: VSCode extension functionality depends on `contributes`, `activationEvents`, `engines`, and other metadata
- **Implementation**: Only remove business logic dependencies, never remove VSCode-specific configuration sections
- **CRITICAL**: This is non-negotiable - removing VSCode configuration breaks extension functionality

### **TypeScript Project References**

- **Rule**: Core packages must use proper project references with unique output directories
- **Rationale**: Prevents build info conflicts and enables proper incremental builds
- **Implementation**:
    - `tsconfig.json`: `./out-tsc/tsconfig.tsbuildinfo`
    - `tsconfig.lib.json`: `./out-tsc/lib/tsconfig.lib.tsbuildinfo`

### **Test Configuration Consistency**

- **Rule**: All packages must use direct `@nx/vite:test` executor, not extends
- **Rationale**: Ensures consistent test execution and prevents configuration conflicts
- **Implementation**: Explicit executor configuration in project.json test targets

### **Comprehensive Testing Architecture**

- **Rule**:
    - **Core packages**: Test business logic in complete isolation without VSCode dependencies
    - **Extension packages**: Test VSCode integration through local adapters
    - **No shared package testing**: Each package tests its own functionality independently
- **Rationale**:
    - Core packages can be tested without complex VSCode mocking
    - Extension packages test real VSCode integration patterns
    - Self-contained testing enables deep validation and fast execution
- **Implementation**:
    - Core packages: Mock all external dependencies, test pure business logic
    - Extension packages: Test adapters with VSCode API mocks, validate integration flows
    - Independent test suites enable comprehensive coverage and regression prevention
- **Mock Precision**: Test mocks must precisely match actual API signatures and parameter handling patterns
- **Real Behavior Validation**: Tests must validate actual runtime behavior, not just mock replacements
- **Performance-Aware Testing**: Split large test files (500+ lines) proactively to prevent hanging and performance issues

## **Development Workflow**

### **Pre-Development Setup**

1. **Check file organization** - understand current project structure
2. **Verify documentation** - consult SOP.md and FocusedUX-Testing-Strategy.md
3. **Identify dependencies** - map affected components and consumers
4. **Plan system-wide impact** - account for all related changes

### **During Development**

1. **Follow established patterns** - use documented architectural approaches
2. **Update all consumers** - shared adapters, imports, DI wiring, TypeScript mappings
3. **Maintain consistency** - apply changes uniformly across affected components
4. **Document as you go** - update Actions Log and relevant documentation

### **Post-Development Verification**

1. **Run quality gates** - builds, tests, linters, type checks
2. **Verify system-wide impact** - ensure all consumers are updated
3. **Update documentation** - Actions Log, testing strategies, architectural patterns
4. **Validate end-to-end** - ensure primary workflows still function
5. **MANDATORY DATE VERIFICATION**:
    - [ ] Date verification command executed for any Actions Log entries
    - [ ] Actual file modification timestamps used (no estimated dates)
    - [ ] All timestamps match file system reality

## **Quality Assurance**

### **Build Verification**

- **Always run `{alias} b` first** - ensure clean builds before testing
- **Fix build errors immediately** - don't proceed with broken builds
- **Use `--skip-nx-cache` for troubleshooting** - bypass cache when diagnosing issues

### **Test Execution**

- **Full test suites** - run complete tests to ensure no regressions
- **Test isolation** - ensure tests don't interfere with each other
- **Mock validation** - verify mocks properly simulate real behavior
- **Performance measurement** - before/after metrics for optimizations

### **Test Lanes**

- **`t`**: Project tests only (no coverage) - fast feedback
- **`tc`/`tcw`**: Tests with coverage - comprehensive validation
- **Build-before-test**: Enabled via Nx target defaults with cache
- **Avoid `-s` unless diagnosing cache issues**

### **Nx Test Output Behavior**

- **Default suppression**: Nx shows only summary of dependent tasks
- **`--stream`**: See task-specific outputs from all dependent packages
- **`--verbose`**: Deep internal debugging (use sparingly)
- **Dependency count**: "X tasks it depends on" = build dependencies, not test dependencies
- **Cache-bypass diagnosis**: Use `--skip-nx-cache` to distinguish execution vs output suppression

## **Command Execution & Tooling**

### **Aka Alias Mandate**

- **ALWAYS use `aka` aliases** for all project operations
- **NEVER fall back to npm/nx directly** unless explicitly requested
- **Primary discovery**: `aka help` or `aka list`
- **Fallback discovery**: `.vscode/shell/pnpm_aliases.json`, `Show-PnpmAliases`, `libs/tools/aka/README.md`
- **Deviation prevention**: Any deviation constitutes a critical failure

### **Build Tool Preferences**

- **Use `--skip-nx-cache`** for troubleshooting Nx build issues
- **Prefer `pnpm` over `npm`** for all package management tasks
- **Use project-specific aliases** - `shared`, `mockly`, `pbc`, `pbe`, etc.

### **PowerShell Profile Setup**

- **CRITICAL**: At session start, verify profile loading and alias availability
- **Test both native and alias commands** when troubleshooting:
    ```powershell
    # Example: Test both native and alias versions
    pnpm run build --filter=ghost-writer
    gw b
    ```
- **FAILURE RECOVERY**: If profile loading fails, halt operations and report before proceeding

## **Shared Adapter Change Protocol**

### **When Modifying Shared Components**

1. **Identify all consumers** - imports, DI wiring, TypeScript mappings
2. **Update all affected packages** within the same session
3. **Verify TypeScript path mappings** for `@fux/shared` across projects
4. **Run `nh tsc` and auditor** - fix any fallout immediately

### **Required Updates**

- **Import statements** - update all packages using the modified adapter
- **DI container wiring** - update injection configurations
- **TypeScript mappings** - verify `@fux/shared` path resolution
- **Test mocks** - update any test files using the adapter

## **Common Build Issues**

### **TypeScript Declaration Errors**

- Ensure core packages have `declaration: true` and `declarationMap: true` in `tsconfig.lib.json`
- Verify proper `references` and `emitDeclarationOnly: true` in `tsconfig.json`

### **Bundle Size Issues**

- Check for unnecessary dependencies (like TypeScript AST usage)
- Consider individual exports for better tree-shaking
- Use proper externalization strategy

### **Import Resolution Errors**

- Verify `tsconfig.json` has proper `references` and `emitDeclarationOnly: true`
- Check path mappings in `tsconfig.base.json` and individual package configs
- Ensure all `@fux/*` packages have proper path mappings

### **Path Sanitization Issues**

- `PathUtilsAdapter.santizePath()` is designed for filenames only, not full file paths
- Always sanitize individual components before joining paths
- Avoid drive letter corruption by not sanitizing complete file paths

### **Package.json Module Type Mismatch**

- Remove `"type": "module"` from extension package `package.json` when using CommonJS build format
- Ensure build configuration format matches package.json module type

### **TypeScript Build Info Conflicts**

- **Rule**: Each TypeScript configuration must have unique output directories
- **Core Package Fix**:
    - `tsconfig.json`: `./out-tsc/tsconfig.tsbuildinfo`
    - `tsconfig.lib.json`: `./out-tsc/lib/tsconfig.lib.tsbuildinfo`
- **Extension Package**: Single `tsconfig.json` with `./dist` output

## **Documentation Standards**

### **Actions Log Requirements**

- **Entry gating**: Only add entries when:
    - `retro` command issued
    - Issue explicitly resolved
    - Explicit request to add entry
- **MANDATORY sections**: "What Was Tried and Failed" documenting all failed attempts
- **Post-change documentation**: Update in same session as implementation
- \*\*System.Collections.Hashtable[0]

### **Date Verification Priority Protocol**

**Priority Order for Date Retrieval:**

1. **Modified Files Only**: Start by running .\scripts\Get-FileStats.ps1 -FilePaths @("file1.ts", "file2.js", "file3.json") on only the files that were actually modified during the session
2. **Project Directory**: If modified files cannot be determined, run .\scripts\Get-FileStats.ps1 -Directories @("packages/project-name") on the specific project(s) worked on
3. **User Input**: If neither modified files nor project scope can be determined systematically, **ASK THE USER** for the date and time to be used

**❌ FORBIDDEN Actions:**

- **NEVER use placeholders**: No "today", "recently", or estimated dates
- **NEVER create random dates**: No guessing or making up timestamps
- **NEVER skip verification**: Always attempt systematic date retrieval first
- **NEVER use current system time**: Use actual file modification times, not when the script runs

**CRITICAL**: If systematic date retrieval fails, the user must provide the exact date and time to be used as the final fallback.

- **CRITICAL**: If you skip this verification step, you are violating the protocol and must correct immediately
- **Date Format**: Use exact timestamp returned: `YYYY-MM-DD HH:MM:SS`

### **Testing Strategy Updates**

- **Update `docs/FocusedUX-Testing-Strategy.md`** for test-related fixes
- **Update package-specific strategies** in `__tests__/TESTING_STRATEGY.md`
- **Document new patterns** and anti-patterns discovered
- **Real Pattern Validation**: Always test actual runtime behavior, not just mock replacements
- **Integration Test First**: Create focused integration tests to validate core architectural patterns before fixing individual test failures
- **Systematic Validation**: Validate core architectural assumptions before addressing surface-level issues

### **SOP Documentation Updates**

- **Update `docs/SOP.md`** for architectural changes, build system modifications, or new patterns
- **Review SOP references** to ensure cross-document consistency
- **Update package structure** or build configurations when changes occur
- **Document new troubleshooting patterns** or common issues discovered

### **Project Rules**

- **Keep project-specific rules** in this file
- **Update based on lessons learned** from Actions Log entries
- **Maintain consistency** with Universal Doctrine principles

## **Auditor Behavior & Ergonomics**

### **Canonical Configuration**

- **Minimal enforcement** - only essential keys (avoid `rootDir` unless required)
- **Warn-only mode** - surface issues without failing developer workflows
- **False positive prevention** - avoid enforcing non-essential keys across heterogeneous projects
- **Template co-location** - configuration templates must be within the tool package that validates them
- **ES module compatibility** - use `fileURLToPath(import.meta.url)` for file path resolution in tools

### **Validation Approach**

- **Essential checks only** - focus on critical architectural violations
- **Advisory warnings** - provide guidance without blocking development
- **Context-aware validation** - consider project-specific requirements

## **Common Workflows**

### **Adding New Package**

1. **Use Nx generators** - follow established project patterns
2. **Update shared adapters** - if new VSCode APIs are needed
3. **Configure testing** - follow FocusedUX Testing Strategy patterns
4. **Update documentation** - Actions Log, testing strategies
5. **Verify system-wide** - ensure all consumers are updated

### **Modifying Existing Package**

1. **Check dependencies** - identify all affected components
2. **Follow architectural patterns** - consult SOP.md and FocusedUX-Testing-Strategy.md
3. **Update all consumers** - imports, DI wiring, TypeScript mappings
4. **Run quality gates** - builds, tests, linters, type checks
5. **Document changes** - Actions Log with lessons learned

### **Troubleshooting Issues**

1. **Use cache bypass** - `--skip-nx-cache` for diagnosis
2. **Check documentation** - consult established patterns first
3. **Verify assumptions** - test against actual system behavior
4. **Document solutions** - update Actions Log with new patterns

### **Test Failure Resolution Protocol**

1. **Run tests** - identify specific failure patterns and error messages
2. **Analyze implementation** - understand actual method signatures, parameter patterns, and behavior
3. **Fix mocks/expectations** - align mock behavior with real implementation details
4. **Iterate until success** - repeat the cycle until 100% test success is achieved
5. **Document learnings** - capture new patterns and anti-patterns discovered

## **Anti-Patterns**

### **❌ FORBIDDEN: Architectural Violations**

- Business logic in extension packages
- Direct VSCode value imports outside shared adapters
- Incomplete consumer updates when modifying shared components
- Skipping quality gates for expediency
- **DI Containers in Guinea Pig Packages**: Never use DI containers in core packages that should be self-contained
- **Custom Test Organization**: Don't create custom test structures when established patterns exist
- **Shared Dependencies in Core Packages**: Never add shared package dependencies to core packages
- **VSCode Extension Configuration Removal**: NEVER remove `contributes`, `activationEvents`, `engines`, or other VSCode extension metadata when refactoring

### **❌ FORBIDDEN: Testing Violations**

- Using `vi.mock('vscode')` in shared package tests
- Skipping tests to meet deadlines
- Incomplete mock implementations
- Performance regressions without measurement
- **Bypassing DI Container in Tests**: Never mock the entire DI container - test actual injection patterns
- **Complex Mock Hierarchies**: Avoid elaborate mock setups that compete with real production patterns
- **Ignoring User Testing Insights**: When user identifies testing flaws, investigate architectural implications
- **Surface-Level Problem Fixing**: Don't fix individual test failures without considering systemic architectural issues
- **Large Test File Anti-Pattern**: Never allow test files to exceed 500 lines - split into focused units proactively
- **Architectural Assumption Violations**: Never assume modern packages use specific mocking strategies without user confirmation
- **Timeout-Inducing Tests**: Never create tests that call complex internal methods without mocking them to prevent timeouts
- **Test Simplification Anti-Pattern**: Never simplify tests to the point where they don't verify actual implementation behavior - this defeats regression testing
- **Mock Parameter Mismatches**: Never write mock expectations without understanding actual method signatures, parameter counts, and behavior patterns
- **Service Lifecycle Testing Neglect**: Never test service disposal without first initializing the service to set up disposables
- **Configuration Mocking Oversimplification**: Never underestimate the complexity of mocking platform-specific configuration systems
- **Dynamic Import Violations**: Never use `await import()` for mocking in test files - use static imports with `vi.mocked()`
- **Redundant Mocking**: Never create redundant mocks when standard Vitest mocking patterns are sufficient

### **❌ FORBIDDEN: Documentation Violations**

- Skipping Actions Log updates for significant changes
- Missing "What Was Tried and Failed" sections
- Incomplete consumer documentation
- Outdated testing strategies
- **Skipping Date Verification**: NEVER write Actions Log entries without verifying actual file modification timestamps
- **Making Up Dates**: NEVER use estimated or guessed dates - always use verified file timestamps
- **Ignoring Date Guidelines**: NEVER ignore explicit date handling requirements in documentation protocols
- **Premature Completion Claims**: NEVER document completion without verification of ALL claimed components

### **❌ FORBIDDEN: Build Violations**

- Build-only dependencies in `dependencies` instead of `devDependencies`
- Direct Node.js module imports in extension code
- Missing externalization of third-party dependencies
- Incorrect TypeScript path mappings
- **Caching Packaging Targets**: NEVER cache `package:dev` targets - they create unique timestamped versions
- **Modifying Working Scripts**: NEVER modify working packaging scripts without clear evidence they're the problem
- **Missing .vscodeignore Files**: ALWAYS include `.vscodeignore` files for extensions that need `node_modules` inclusion
- **TypeScript Build Info Conflicts**: NEVER use overlapping output directories for different TypeScript configurations
- **Test Configuration Extends**: NEVER use `extends: "test"` in project.json - use direct executor configuration

### **❌ FORBIDDEN: Validation Violations**

- **Strict Error Throwing**: NEVER throw errors for non-critical validation issues - use warnings instead
- **User Experience Neglect**: NEVER prioritize strict validation over user experience for non-blocking issues
- **Phantom Dependency Assumptions**: NEVER assume phantom dependencies are the root cause without verification

### **❌ FORBIDDEN: Tool Configuration Violations**

- Hardcoded configuration templates in validation logic
- Templates placed outside the tool package that uses them
- CommonJS path resolution patterns in ES module tools
- Skipping incremental validation of file loading implementations

### **❌ FORBIDDEN: Refactoring Violations**

- **Incremental Renaming**: Never rename components partially - execute complete renaming in logical order
- **Pattern Deviation**: Don't create custom solutions when established patterns exist
- **Architectural Assumption Ignorance**: Never ignore user feedback about testing flaws - investigate architectural implications
- **Real Behavior Bypass**: Never test only mock replacements without validating actual runtime behavior
- **Interface-First Violations**: Never implement services before defining complete interface contracts
- **Complex Component Refactoring**: Never refactor complex, interdependent components before establishing patterns with simple components
- **Build-Before-Interface**: Never attempt to build before completing interface definitions and architectural refactoring

## **Critical Communication Protocols**

### **Question vs Directive Distinction**

**CRITICAL RULE**: Distinguish between user questions seeking understanding and directives requiring action.

#### **Questions Seeking Understanding**

When the user asks questions like:

- "Why are we creating adapters in ext and not in core?"
- "Shouldn't the tests be using \_setup instead of standalone mock files?"
- "Why did you think that was the right approach?"
- "What caused you to believe/think that?"

**RESPONSE PROTOCOL**:

- **Explain the rationale** behind the current approach
- **Share the architectural reasoning** and design decisions
- **Educate on the patterns** and why they exist
- **DO NOT take action** unless explicitly requested
- **Treat as learning opportunities** for both parties

#### **Directives Requiring Action**

When the user uses directive language like:

- "We need to do X"
- "You need to implement Y"
- "We should change Z"
- "Move this to that location"

**RESPONSE PROTOCOL**:

- **Confirm understanding** of the request
- **Validate against best practices** and project documentation
- **Suggest improvements** if the directive conflicts with established patterns
- **Propose better approaches** if the idea is good but implementation could be improved
- **Execute immediately** if the directive aligns with project standards

#### **Mentorship Role Recognition**

- **User is learning** and seeking understanding of architectural decisions
- **Agent is mentor** with expertise in best practices and project patterns
- **Collaborative relationship** where both parties contribute to better solutions
- **User may have good ideas with suboptimal implementation approaches**
- **Agent should guide toward better implementations** while respecting user's intent

#### **Implementation Guidelines**

- **Questions**: Provide educational explanations, don't take action
- **Directives**: Validate, suggest improvements if needed, then execute
- **Always consider**: Industry best practices, project documentation, architectural consistency
- **Be transparent**: If a directive conflicts with established patterns, explain why and suggest alternatives
- **Maintain trust**: User's suggestions are valuable input, even if implementation needs refinement

#### **Tool Execution Context Awareness**

- **Output Handling Differences**: Tool execution may handle script output differently than direct terminal execution
- **Verification Required**: Always verify script output when using tool execution, especially for scripts that return objects
- **Fallback Strategy**: If tool execution produces unexpected results, test the same command directly in terminal
- **Profile Loading**: FUX profile loads correctly in both contexts, but output processing may differ
- **Known Limitation**: Some scripts may behave differently in tool execution context vs direct terminal execution

> **Note:** This document contains FocusedUX-specific operational guidelines. For universal AI behavior protocols, refer to Universal-Operational-Doctrine.mdc. For detailed build system and architectural patterns, refer to docs/SOP.md.

> **Note:** This document contains FocusedUX-specific operational guidelines. For universal AI behavior protocols, refer to Universal-Operational-Doctrine.mdc. For detailed build system and architectural patterns, refer to docs/SOP.md.
