# FocusedUX Operational Doctrine

## **Project Architecture**

### **File Organization**

- **Packages**: `packages/` directory (extensions, core packages)
- **Libraries**: `libs/` directory (shared, mockly, tools)
- **Documentation**: `docs/` directory (strategies, logs, SOPs)
- **Configuration**: Root-level configs (`.cursor/rules/`, `nx.json`, etc.)

### **Package Archetypes**

- **`shared` (Library)**: Located in `libs/shared/`, contains shared services and abstractions for runtime use by other packages
- **`core` (Library)**: Located in `packages/{feature}/core/`, contains feature's abstract business logic, built to be tree-shakeable
- **`ext` (Application)**: Located in `packages/{feature}/ext/`, contains VSCode extension implementation, depends on core package
- **`tool` (Utility)**: Located in `libs/tools/{tool-name}/`, contains standalone utilities that run directly with tsx (no build step)

### **Package Structure Decision Tree**

```
Is the package intended to be a VS Code extension?
├─ YES → Use core/ext pattern (packages/{feature}/core + packages/{feature}/ext)
│   ├─ core: Library with business logic, built with @nx/esbuild:esbuild (bundle: false)
│   └─ ext: Application bundle, built with @nx/esbuild:esbuild (bundle: true)
│
├─ NO → Is the package a shared library consumed by other packages?
│   ├─ YES → Use shared pattern (libs/shared)
│   │   └─ Built with @nx/esbuild:esbuild (bundle: false), generates declarations
│   │
│   └─ NO → Is the package a standalone tool/utility that runs directly?
│       ├─ YES → Use tool pattern (libs/tools/{tool-name})
│       │   ├─ Runs directly with tsx (no build step)
│       │   ├─ Uses nx:run-commands executor for execution
│       │   ├─ No declaration generation (composite: false, declaration: false)
│       │   ├─ Dependencies in devDependencies (not dependencies)
│       │   └─ **Guinea Pig Package**: Self-contained without shared dependencies, uses direct instantiation
│       │
│       └─ NO → Reconsider package purpose or consult team
```

### **Core Architectural Principles**

- **VSCode API Import Rules**: Value imports for VSCode APIs must come only from shared adapters
- **Direct VSCode imports**: Limited to types only for decoupling and complete injection
- **Thin Wrapper Extensions**: Extension packages contain only VSCode integration code
- **Business Logic in Core**: All business logic belongs in core packages, not extensions
- **Guinea Pig Package Principles**: Core packages should be self-contained without shared dependencies, using direct instantiation rather than DI containers

---

## **Systematic Refactoring Protocols**

### **Large-Scale Renaming Protocol**

When renaming packages, features, or commands across the entire codebase:

1. **Logical Order Execution**:
    - Directories → Package Names → Command IDs → Display Names → Configuration Files → Documentation
2. **Verification at Each Step**:
    - Run builds and tests after each phase to catch issues early
    - Update aliases and references immediately
3. **Comprehensive Coverage**:
    - All package.json files (name, dependencies, devDependencies)
    - All project.json files (name, paths, commands)
    - All source files (imports, exports, class names)
    - All test files (descriptions, mock names)
    - All documentation (README files, comments, examples)
    - All configuration files (nx.json, tsconfig files, vitest configs)

### **Architectural Feedback Integration**

When users provide feedback about testing or implementation issues:

1. **Treat as Architectural Revelation**: User feedback about testing flaws may reveal fundamental architectural problems
2. **Investigate Systemic Issues**: Don't fix surface-level problems without considering architectural implications
3. **Create Focused Integration Tests**: Validate actual runtime behavior, not just mock replacements
4. **Test Real Patterns**: Use integration tests to validate core architectural patterns before fixing individual issues
5. **User Preference Enforcement**: Strictly adhere to user's architectural preferences even when they conflict with initial assumptions

### **Pattern Alignment Protocol**

When implementing new features or refactoring existing code:

1. **Follow Established Patterns**: Use documented architectural approaches rather than creating custom solutions
2. **Test Structure Alignment**: Follow established project patterns for test organization and setup
3. **Architectural Compliance Verification**: Validate core architectural assumptions before addressing surface-level issues
4. **Documentation Consistency**: Ensure alignment with existing documentation and patterns

---

## **Critical Architectural Rules**

### **Adapter Architecture**

- **Rule**: All adapters MUST be in the shared package (`@fux/shared`)
- **Rationale**: Ensures consistent abstraction across all packages, prevents duplication, maintains single source of truth
- **Implementation**: Create adapters in `libs/shared/src/vscode/adapters/`, export from `libs/shared/src/index.ts`

### **VSCode Value Import Restrictions**

- **Rule**: NO VSCode values are to be imported outside of adapters in the shared package
- **Rationale**: Maintains decoupling from VSCode API, enables complete dependency injection
- **Implementation**: Only import VSCode types (using `import type`) outside of adapters

### **Dependency Management**

- **Rule**: Build-only dependencies must be in `devDependencies`
- **Rationale**: Prevents extraneous dependencies in production packages, reduces VSIX package size
- **Implementation**: Runtime dependencies in `dependencies`, build/development dependencies in `devDependencies`

### **Externalization Strategy**

- **Rule**: All third-party dependencies must be properly externalized
- **Rationale**: Ensures clean dependency management, prevents bundling issues
- **Implementation**: List all runtime dependencies in `external` array in build configuration

### **Node.js Module Import Restrictions**

- **Rule**: NO direct Node.js module imports in extension code
- **Rationale**: VSCode extensions should not include Node.js built-in modules as dependencies
- **Implementation**: Use VSCode's built-in file system API through workspace adapters

### **Shared Path Alias Resolution**

- **Rule**: TypeScript path alias for `@fux/shared` must point to package root (`libs/shared`), not `libs/shared/src`
- **Rationale**: Ensures consumers use referenced project's declaration output instead of inlining sources
- **Implementation**: Set path mapping to package root in consumer `tsconfig.lib.json`

### **Guinea Pig Package Architecture**

- **Rule**: Core packages must be self-contained without shared dependencies
- **Rationale**: Enables independent testing and validation of core logic
- **Implementation**: Use direct service instantiation, not DI containers; mock all external dependencies in tests

---

## **Dependency Injection with Awilix**

### **Framework**

The project uses **awilix** for dependency injection across all packages.

### **Container Setup**

Each extension package includes an `injection.ts` file that sets up the DI container.

### **Service Registration**

All services (core, shared, and adapters) are registered in the DI container.

### **Static Imports**

`awilix` and other externalized packages **MUST** be imported using static, top-level `import` statements.

### **Dependency Injection Best Practices**

- **One Container Per Extension**: Each extension has its own DI container
- **Use Factories for Dependencies**: Services that depend on other services **MUST** use factory functions (`asFunction`)
- **Register All Dependencies**: Container **MUST** provide concrete implementation for every interface
- **Import Required Interfaces**: All interfaces used in DI registration **MUST** be imported from respective packages

### **Common DI Pitfalls & Troubleshooting**

- **`AwilixResolutionError`**: Almost always means a dependency is missing from the container
- **Hallucinated Adapters**: Do not assume an adapter exists in `@fux/shared`
- **Path Sanitization Issues**: `PathUtilsAdapter.santizePath()` is designed for filenames only
- **Missing Interface Imports**: DI container registration requires proper interface imports

---

## **Build System Architecture**

### **Build Configuration Requirements**

- **Core Package**: Use `tsconfig.lib.json` with `declaration: true`, `declarationMap: true`
- **Extension Package**: Use `tsconfig.json` with CommonJS module format
- **Tool Package**: Use `tsconfig.json` with `composite: false`, `declaration: false`

### **Build Target Configuration**

- **Core Package**: Use `@nx/esbuild:esbuild` with `bundle: false`, `format: ["esm"]`
- **Extension Package**: Use `@nx/esbuild:esbuild` with `bundle: true`, `format: ["cjs"]`
- **Tool Package**: Use `nx:run-commands` executor for direct tsx execution

### **Global Targets in nx.json**

The workspace defines standardized global targets under `targetDefaults`:

- **`build:core`**: For core packages with `bundle: false`
- **`build:extension`**: For extension packages with `bundle: true`

---

## **Development Workflow**

### **Pre-Development Setup**

1. **Check file organization** - understand current project structure
2. **Verify documentation** - consult SOP.md and FocusedUX-Testing-Strategy.md
3. **Identify dependencies** - map affected components and consumers
4. **Plan system-wide impact** - account for all related changes

### **During Development**

1. **Follow established patterns** - use documented architectural approaches
2. **Update all consumers** - shared adapters, imports, DI wiring, TypeScript mappings
3. **Maintain consistency** - apply changes uniformly across affected components
4. **Document as you go** - update Actions Log and relevant documentation

### **Post-Development Verification**

1. **Run quality gates** - builds, tests, linters, type checks
2. **Verify system-wide impact** - ensure all consumers are updated
3. **Update documentation** - Actions Log, testing strategies, architectural patterns
4. **Validate end-to-end** - ensure primary workflows still function
5. **MANDATORY DATE VERIFICATION**:
    - [ ] Date verification command executed for any Actions Log entries
    - [ ] Actual file modification timestamps used (no estimated dates)
    - [ ] All timestamps match file system reality

---

## **Quality Assurance**

### **Build Verification**

- **Always run `{alias} b` first** - ensure clean builds before testing
- **Fix build errors immediately** - don't proceed with broken builds
- **Use `--skip-nx-cache` for troubleshooting** - bypass cache when diagnosing issues

### **Test Execution**

- **Full test suites** - run complete tests to ensure no regressions
- **Test isolation** - ensure tests don't interfere with each other
- **Mock validation** - verify mocks properly simulate real behavior
- **Performance measurement** - before/after metrics for optimizations

### **Test Lanes**

- **`t`**: Project tests only (no coverage) - fast feedback
- **`tc`/`tcw`**: Tests with coverage - comprehensive validation
- **Build-before-test**: Enabled via Nx target defaults with cache
- **Avoid `-s` unless diagnosing cache issues**

### **Nx Test Output Behavior**

- **Default suppression**: Nx shows only summary of dependent tasks
- **`--stream`**: See task-specific outputs from all dependent packages
- **`--verbose`**: Deep internal debugging (use sparingly)
- **Dependency count**: "X tasks it depends on" = build dependencies, not test dependencies
- **Cache-bypass diagnosis**: Use `--skip-nx-cache` to distinguish execution vs output suppression

---

## **Command Execution & Tooling**

### **Aka Alias Mandate**

- **ALWAYS use `aka` aliases** for all project operations
- **NEVER fall back to npm/nx directly** unless explicitly requested
- **Primary discovery**: `aka help` or `aka list`
- **Fallback discovery**: `.vscode/shell/pnpm_aliases.json`, `Show-PnpmAliases`, `libs/tools/aka/README.md`
- **Deviation prevention**: Any deviation constitutes a critical failure

### **Build Tool Preferences**

- **Use `--skip-nx-cache`** for troubleshooting Nx build issues
- **Prefer `pnpm` over `npm`** for all package management tasks
- **Use project-specific aliases** - `shared`, `mockly`, `pbc`, `pbe`, etc.

### **PowerShell Profile Setup**

- **CRITICAL**: At session start, verify profile loading and alias availability
- **Test both native and alias commands** when troubleshooting:
    ```powershell
    # Example: Test both native and alias versions
    pnpm run build --filter=ghost-writer
    gw b
    ```
- **FAILURE RECOVERY**: If profile loading fails, halt operations and report before proceeding

---

## **Shared Adapter Change Protocol**

### **When Modifying Shared Components**

1. **Identify all consumers** - imports, DI wiring, TypeScript mappings
2. **Update all affected packages** within the same session
3. **Verify TypeScript path mappings** for `@fux/shared` across projects
4. **Run `nh tsc` and auditor** - fix any fallout immediately

### **Required Updates**

- **Import statements** - update all packages using the modified adapter
- **DI container wiring** - update injection configurations
- **TypeScript mappings** - verify `@fux/shared` path resolution
- **Test mocks** - update any test files using the adapter

---

## **Common Build Issues**

### **TypeScript Declaration Errors**

- Ensure core packages have `declaration: true` and `declarationMap: true` in `tsconfig.lib.json`
- Verify proper `references` and `emitDeclarationOnly: true` in `tsconfig.json`

### **Bundle Size Issues**

- Check for unnecessary dependencies (like TypeScript AST usage)
- Consider individual exports for better tree-shaking
- Use proper externalization strategy

### **Import Resolution Errors**

- Verify `tsconfig.json` has proper `references` and `emitDeclarationOnly: true`
- Check path mappings in `tsconfig.base.json` and individual package configs
- Ensure all `@fux/*` packages have proper path mappings

### **Path Sanitization Issues**

- `PathUtilsAdapter.santizePath()` is designed for filenames only, not full file paths
- Always sanitize individual components before joining paths
- Avoid drive letter corruption by not sanitizing complete file paths

### **Package.json Module Type Mismatch**

- Remove `"type": "module"` from extension package `package.json` when using CommonJS build format
- Ensure build configuration format matches package.json module type

---

## **Documentation Standards**

### **Actions Log Requirements**

- **Entry gating**: Only add entries when:
    - `retro` command issued
    - Issue explicitly resolved
    - Explicit request to add entry
- **MANDATORY sections**: "What Was Tried and Failed" documenting all failed attempts
- **Post-change documentation**: Update in same session as implementation
- **MANDATORY DATE VERIFICATION**: You MUST run `Get-ChildItem "path/to/project" -Recurse | Measure-Object -Property LastWriteTime -Maximum` to get the latest modification time
- **CRITICAL**: If you skip this verification step, you are violating the protocol and must correct immediately
- **Date Format**: Use exact timestamp returned: `YYYY-MM-DD HH:MM:SS`

### **Testing Strategy Updates**

- **Update `docs/FocusedUX-Testing-Strategy.md`** for test-related fixes
- **Update package-specific strategies** in `__tests__/TESTING_STRATEGY.md`
- **Document new patterns** and anti-patterns discovered
- **Real Pattern Validation**: Always test actual runtime behavior, not just mock replacements
- **Integration Test First**: Create focused integration tests to validate core architectural patterns before fixing individual test failures
- **Systematic Validation**: Validate core architectural assumptions before addressing surface-level issues

### **SOP Documentation Updates**

- **Update `docs/SOP.md`** for architectural changes, build system modifications, or new patterns
- **Review SOP references** to ensure cross-document consistency
- **Update package structure** or build configurations when changes occur
- **Document new troubleshooting patterns** or common issues discovered

### **Project Rules**

- **Keep project-specific rules** in this file
- **Update based on lessons learned** from Actions Log entries
- **Maintain consistency** with Universal Doctrine principles

---

## **Auditor Behavior & Ergonomics**

### **Canonical Configuration**

- **Minimal enforcement** - only essential keys (avoid `rootDir` unless required)
- **Warn-only mode** - surface issues without failing developer workflows
- **False positive prevention** - avoid enforcing non-essential keys across heterogeneous projects
- **Template co-location** - configuration templates must be within the tool package that validates them
- **ES module compatibility** - use `fileURLToPath(import.meta.url)` for file path resolution in tools

### **Validation Approach**

- **Essential checks only** - focus on critical architectural violations
- **Advisory warnings** - provide guidance without blocking development
- **Context-aware validation** - consider project-specific requirements

---

## **Common Workflows**

### **Adding New Package**

1. **Use Nx generators** - follow established project patterns
2. **Update shared adapters** - if new VSCode APIs are needed
3. **Configure testing** - follow FocusedUX Testing Strategy patterns
4. **Update documentation** - Actions Log, testing strategies
5. **Verify system-wide** - ensure all consumers are updated

### **Modifying Existing Package**

1. **Check dependencies** - identify all affected components
2. **Follow architectural patterns** - consult SOP.md and FocusedUX-Testing-Strategy.md
3. **Update all consumers** - imports, DI wiring, TypeScript mappings
4. **Run quality gates** - builds, tests, linters, type checks
5. **Document changes** - Actions Log with lessons learned

### **Troubleshooting Issues**

1. **Use cache bypass** - `--skip-nx-cache` for diagnosis
2. **Check documentation** - consult established patterns first
3. **Verify assumptions** - test against actual system behavior
4. **Document solutions** - update Actions Log with new patterns

---

## **Anti-Patterns**

### **❌ FORBIDDEN: Architectural Violations**

- Business logic in extension packages
- Direct VSCode value imports outside shared adapters
- Incomplete consumer updates when modifying shared components
- Skipping quality gates for expediency
- **DI Containers in Guinea Pig Packages**: Never use DI containers in core packages that should be self-contained
- **Custom Test Organization**: Don't create custom test structures when established patterns exist

### **❌ FORBIDDEN: Testing Violations**

- Using `vi.mock('vscode')` in shared package tests
- Skipping tests to meet deadlines
- Incomplete mock implementations
- Performance regressions without measurement
- **Bypassing DI Container in Tests**: Never mock the entire DI container - test actual injection patterns
- **Complex Mock Hierarchies**: Avoid elaborate mock setups that compete with real production patterns
- **Ignoring User Testing Insights**: When user identifies testing flaws, investigate architectural implications
- **Surface-Level Problem Fixing**: Don't fix individual test failures without considering systemic architectural issues

### **❌ FORBIDDEN: Documentation Violations**

- Skipping Actions Log updates for significant changes
- Missing "What Was Tried and Failed" sections
- Incomplete consumer documentation
- Outdated testing strategies
- **Skipping Date Verification**: NEVER write Actions Log entries without verifying actual file modification timestamps
- **Making Up Dates**: NEVER use estimated or guessed dates - always use verified file timestamps
- **Ignoring Date Guidelines**: NEVER ignore explicit date handling requirements in documentation protocols

### **❌ FORBIDDEN: Build Violations**

- Build-only dependencies in `dependencies` instead of `devDependencies`
- Direct Node.js module imports in extension code
- Missing externalization of third-party dependencies
- Incorrect TypeScript path mappings
- **Caching Packaging Targets**: NEVER cache `package:dev` targets - they create unique timestamped versions
- **Modifying Working Scripts**: NEVER modify working packaging scripts without clear evidence they're the problem
- **Missing .vscodeignore Files**: ALWAYS include `.vscodeignore` files for extensions that need `node_modules` inclusion

### **❌ FORBIDDEN: Validation Violations**

- **Strict Error Throwing**: NEVER throw errors for non-critical validation issues - use warnings instead
- **User Experience Neglect**: NEVER prioritize strict validation over user experience for non-blocking issues
- **Phantom Dependency Assumptions**: NEVER assume phantom dependencies are the root cause without verification

### **❌ FORBIDDEN: Tool Configuration Violations**

- Hardcoded configuration templates in validation logic
- Templates placed outside the tool package that uses them
- CommonJS path resolution patterns in ES module tools
- Skipping incremental validation of file loading implementations

### **❌ FORBIDDEN: Refactoring Violations**

- **Incremental Renaming**: Never rename components partially - execute complete renaming in logical order
- **Pattern Deviation**: Don't create custom solutions when established patterns exist
- **Architectural Assumption Ignorance**: Never ignore user feedback about testing flaws - investigate architectural implications
- **Real Behavior Bypass**: Never test only mock replacements without validating actual runtime behavior

---

> **Note:** This document contains FocusedUX-specific operational guidelines. For universal AI behavior protocols, refer to Universal-Operational-Doctrine.mdc. For detailed build system and architectural patterns, refer to docs/SOP.md.
