# AI-Optimized Protocol Retrospective

## **DOCUMENT PURPOSE**

**Primary Consumer**: AI Agent performing systematic learning and improvement
**Objective**: Systematic session analysis and continuous improvement integration
**Scope**: Session analysis, lesson distillation, doctrine integration, and documentation updates

## **CRITICAL PRE-RESPONSE VALIDATION FRAMEWORK**

### **MANDATORY EXECUTION CHECKLIST**

**CRITICAL**: Before ANY retrospective action, execute this validation sequence:

**STEP 1: RETROSPECTIVE TRIGGER VERIFICATION**

- [ ] **Command Detection**: Has user issued `retro` command?
- [ ] **Session Scope**: Is this a complete session review from initial request to current point?
- [ ] **Learning Focus**: Am I focused on behavioral insights and transferable lessons?

**STEP 2: ANALYSIS PHASE VALIDATION**

- [ ] **Conversation Review**: Will I review every turn of the conversation systematically?
- [ ] **Self-Critical Focus**: Will I focus on failures, corrections, and actionable lessons?
- [ ] **Insight Limitation**: Will I limit to ≤10 key behavioral insights?

**STEP 3: DISTILLATION PHASE VALIDATION**

- [ ] **Universal Principles**: Will I extract lessons that apply across any project/context?
- [ ] **Project-Specific Patterns**: Will I identify FocusedUX-specific architectural patterns?
- [ ] **Anti-Pattern Recognition**: Will I identify specific, dangerous actions to forbid?

**STEP 4: INTEGRATION PHASE VALIDATION**

- [ ] **Doctrine Routing**: Will I route lessons to correct rule files (Universal vs Project)?
- [ ] **Documentation Updates**: Will I present proposed updates for user review first?
- [ ] **Quality Assurance**: Will I verify changes before reporting completion?

**VIOLATION PENALTY**: Any failure to complete this checklist constitutes a critical failure requiring immediate acknowledgment and correction.

## **EXECUTION FLOW FRAMEWORK**

### **PHASE 1: SESSION ANALYSIS (CHAT-ONLY REFLECTION)**

**DIRECTIVE**: Review every turn of the conversation from initial user request to this point. Synthesize findings into a concise, self-critical analysis.

**OUTPUT STRUCTURE** (Keep in chat only):

- **Bulleted list** (≤10 points) of key behavioral insights
- **Focus on**: Successes, failures & corrections, actionable lessons

**SUCCESS ANALYSIS CRITERIA:**

- What core principles or patterns led to efficient and correct outcomes?
- Which established workflows proved effective?

**FAILURE ANALYSIS CRITERIA:**

- Where did your approach fail? What was the root cause?
- How did the user's feedback correct your behavior?
- What misdiagnoses occurred and why?

**ACTIONABLE LESSON CRITERIA:**

- What are the most critical, transferable lessons from this interaction?
- What patterns should be repeated or avoided in the future?

### **PHASE 2: LESSON DISTILLATION**

**DIRECTIVE**: Filter and abstract only the most valuable insights into **durable, universal principles.**

**KEEP (Universal Principles):**

- ✅ **Universal Principles**: Lessons that apply across any language, framework, or project
- ✅ **Critical Anti-Patterns**: Specific, dangerous actions that must be forbidden
- ✅ **Effective Protocols**: High-level workflows that proved successful
- ✅ **New User Feedback Patterns**: Insights from user corrections that reveal core logic flaws

**DISCARD (Project-Specific Details):**

- ❌ **Project-Specific Details**: File paths, port numbers, specific function names
- ❌ **One-Off Trivia**: Information that is not a reusable pattern
- ❌ **Session Narrative**: The story of what you did (focus only on learning)

### **PHASE 3: PROJECT-SPECIFIC DISTILLATION**

**DIRECTIVE**: Extract project-specific lessons that apply specifically to the FocusedUX project architecture, workflows, and patterns.

**KEEP (Project-Specific Principles):**

- ✅ **FocusedUX Architectural Patterns**: Lessons about core/ext patterns, VSCode import rules, package structure
- ✅ **Project Workflow Insights**: Nx-specific patterns, build system configurations, testing strategies
- ✅ **Documentation Organization**: Project-specific documentation routing and categorization patterns
- ✅ **Protocol Design Patterns**: How protocols should work within the FocusedUX ecosystem
- ✅ **Tool-Specific Lessons**: Insights about project-specific tools, scripts, and utilities

**DISCARD (Generic Details):**

- ❌ **Universal Principles**: These go to Universal Doctrine
- ❌ **One-Off Implementation Details**: Specific file changes, exact commands run
- ❌ **Temporary Workarounds**: Solutions that don't represent lasting patterns

## **DOCTRINE INTEGRATION EXECUTION FRAMEWORK**

### **RULE FILE SELECTION PROTOCOL**

**UNIVERSAL TARGET** (`.cursor/rules/OperationalDoctrine_Universal.mdc`):

- Universal AI behavior, operational workflows, cross-project principles
- Communication patterns, response validation, quality assurance

**PROJECT-SPECIFIC TARGET** (`.cursor/rules/OperationalDoctrine_FocusedUX(workspace).mdc`):

- Repo workflows, testing patterns, architectural rules, project conventions
- FocusedUX-specific patterns, Nx workflows, VSCode integration

**NON-DUPLICATION RULE**: If both could apply, prefer project-specific; update universal only if it adds non-duplicative value

### **INTEGRATION PROTOCOL**

**STEP 1: READ AND UNDERSTAND**

- [ ] Read the target rule file to understand current structure
- [ ] Identify logical sections for each distilled lesson
- [ ] Plan integration without disrupting existing patterns

**STEP 2: REFINE, DON'T JUST APPEND**

- [ ] Improve existing rules with new insights
- [ ] Add new rules following established formatting
- [ ] Maintain consistency with existing voice and structure

**STEP 3: QUALITY ASSURANCE**

- [ ] **Voice**: Imperative and authoritative ("Always...", "Never...", "FORBIDDEN:...")
- [ ] **Language**: 100% universal and tool-agnostic (natural language only)
- [ ] **Conciseness**: Clear, concise, and non-redundant

**STEP 4: VERIFICATION**

- [ ] Read-Write-Reread: Confirm changes before reporting completion
- [ ] Write-Location Checklist: Explicitly list files and sections updated
- [ ] Pattern Consistency: Verify alignment with existing doctrine structure

## **DOCUMENTATION UPDATE EXECUTION FRAMEWORK**

### **PREFLIGHT DOCUMENTATION REVIEW**

**MANDATORY**: Present proposed updates for user review before proceeding:

**ARCHITECTURE UPDATES** (`docs/Architecture.md`):

- Protocol vs Documentation distinction
- Documentation routing framework
- Architectural pattern refinements

**SOP UPDATES** (`docs/SOP.md`):

- Protocol refinement workflow
- Documentation organization principles
- Operational procedure improvements

**TESTING STRATEGY UPDATES** (`docs/FocusedUX-Testing-Strategy.md`):

- Test-related lessons learned
- New anti-patterns discovered
- Testing workflow improvements

**ACTIONS LOG ENTRY**:

- Session summary with key implementations and lessons learned
- Date verification using actual file modification timestamps

### **DOCUMENTATION EXECUTION PROTOCOL**

**ACTIONS LOG DOCUMENTATION:**

- **Location**: `./docs/Actions-Log.md`
- **Format**: Date and descriptive title, high-level summary, key implementations, lessons learned
- **Placement**: Add to TOP of document
- **Purpose**: Living reference for successful patterns and solutions

**DATE/TIME PROTOCOL:**

- **MANDATORY**: Use PowerShell to get actual last modified time of files worked on
- **Specific Files**: `.\scripts\Get-FileStats.ps1 -FilePaths @("file1.ts", "file2.js")`
- **Project Directory**: `.\scripts\Get-FileStats.ps1 -Directories @("packages/project-name")`
- **Format**: Use `[YYYY-MM-DD HH:MM:SS]` format for all Actions Log entry titles
- **Example**: `### [2025-08-22 13:11:06] Dynamicons Test Performance Optimization`

**CHANGELOG UPDATE PROTOCOL:**

- **Automatic Trigger**: After completing any Actions Log entry, if changes affected packages
- **Locations**: `packages/{package-name}/core/CHANGELOG.md`, `packages/{package-name}/ext/CHANGELOG.md`
- **Format**: Follow established format with Added, Changed, Fixed, Technical Improvements sections
- **Version Tracking**: Use same date format as Actions Log entry for consistency

## **QUALITY ASSURANCE EXECUTION FRAMEWORK**

### **DOCUMENTATION STANDARDS VERIFICATION**

**ACTIONS LOG REQUIREMENTS:**

- **Entry gating**: Only add entries when `retro` command issued, issue explicitly resolved, or explicit request
- **MANDATORY sections**: "What Was Tried and Failed" documenting all failed attempts
- **Post-change documentation**: Update in same session as implementation

**DATE VERIFICATION PRIORITY PROTOCOL:**

- **Priority 1**: Modified Files Only - Run on specific files that were modified
- **Priority 2**: Project Directory - Run on project directory if specific files unknown
- **Priority 3**: User Input - Ask user for exact date/time as final fallback

**MANDATORY**: Always use actual file modification timestamps, never estimate or guess dates.

### **DOCUMENTATION CONSISTENCY VERIFICATION**

**BEFORE IMPLEMENTATION**: Consult `docs/SOP.md` and `docs/FocusedUX-Testing-Strategy.md`
**DURING IMPLEMENTATION**: Reference documents to prevent deviations
**AFTER IMPLEMENTATION**: Verify alignment with documented patterns
**CRITICAL RULE**: Obtain explicit user verification before deviating from global strategies

## **FINAL REPORT EXECUTION FRAMEWORK**

### **REPORT STRUCTURE PROTOCOL**

**MANDATORY REPORT COMPONENTS:**

1. **Status of Doctrine**:
    - `✅ Universal Operational Doctrine updated.` OR
    - `✅ FocusedUX Operational Doctrine updated.` OR
    - `ℹ️ No universal lessons were distilled; no updates required.`

2. **Session Analysis**: The full bulleted list from Phase 1

3. **Files Updated**: Explicit list of files and sections modified

4. **Key Learnings**: Most important insights for future sessions

### **EXECUTION TRIGGER PROTOCOL**

**COMMAND**: `retro` - Triggers full retrospective analysis
**SCOPE**: Entire session review and learning integration
**OUTPUT**: Structured learning report with doctrine updates
**INTEGRATION**: Updates both Universal and FocusedUX doctrine files as appropriate

## **EXECUTION PRIORITY MATRIX**

### **CRITICAL PRIORITY** (Execute immediately)

- Retrospective trigger verification
- Session analysis execution
- Lesson distillation validation
- Doctrine integration routing

### **HIGH PRIORITY** (Execute before proceeding)

- Project-specific distillation
- Preflight documentation review
- User approval confirmation
- Quality assurance verification

### **MEDIUM PRIORITY** (Execute during normal operation)

- Documentation execution
- Doctrine file updates
- Pattern consistency verification
- Final report generation

### **LOW PRIORITY** (Execute when time permits)

- Process optimization
- Pattern documentation
- Lesson sharing
- Future planning

---

**REMINDER**: This protocol is how you evolve. Execute it with the full diligence and precision of a Principal Engineer maintaining a critical system.
