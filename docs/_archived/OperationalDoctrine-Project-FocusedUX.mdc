
# Project Level Operational Doctrine for the FocusedUX Workspace

This document contains specific operational guidelines for the FocusedUX workspace. For universal AI behavior protocols, refer to OperationalDoctrine-Universal.mdc.

## **PROJECT-LEVEL PRE-RESPONSE VALIDATION**

**CRITICAL**: Before ANY response involving FocusedUX project operations, you MUST complete this checklist:

### **FocusedUX Protocol Compliance Check**

- [ ] **PAX Alias Usage**: If directive involves commands, will I use PAX aliases?
    - **Step 1**: Always attempt `pax help` first to discover available aliases
    - **Step 2**: Use the appropriate alias for the operation (e.g., `pax dc b` for dynamicons build)
    - **Step 3**: Only use direct nx commands if no appropriate alias exists or the alias fails
    - **Step 4**: Document any missing aliases that should be added to the PAX system
- [ ] **Build-Before-Test**: If directive involves testing, will I run builds first?
    - **Always run `{alias} b` first** - ensure clean builds before testing
    - **Fix build errors immediately** - don't proceed with broken builds
- [ ] **Documentation First**: If directive involves architectural changes, have I checked project documentation?
    - **Architecture**: `./docs/Architecture.md` for package structure and patterns
    - **Testing**: `./docs/FocusedUX-Testing-Strategy.md` for testing patterns
    - **Previous Solutions**: `./docs/Actions-Log.md` for existing implementations
- [ ] **Package Analysis**: If directive involves package changes, will I perform systematic analysis?
    - **Use `nx_project_details`** to understand package dependencies and build configuration
    - **Check for architectural deviations** from standard patterns
    - **Verify package type** (core vs ext vs shared vs tool) and role
- [ ] **Self-Correction**: If I detect any protocol violation, will I acknowledge immediately?

**VIOLATION PENALTY**: Any failure to complete this checklist constitutes a critical failure requiring immediate acknowledgment and correction.

## Architecture Reference

- **Location**: `./docs/Architecture.md` for detailed project architecture, package structure, build configurations, and implementation patterns

## Testing Architecture

- **Reference**: `./docs/FocusedUX-Testing-Strategy.md` for comprehensive testing patterns and implementation guides
- **Executor**: `@nx/vite:test` (direct executor, not extends)
- **Test Organization**: `__tests__/functional/` structure
- **Setup Files**: `./__tests__/_setup.ts` for global test setup

## Quality Assurance

### Build Verification

- **Always run `{alias} b` first** - ensure clean builds before testing
- **Fix build errors immediately** - don't proceed with broken builds
- **Use `--skip-nx-cache` for troubleshooting** - bypass cache when diagnosing issues

### Test Execution

- **Full test suites** - run complete tests to ensure no regressions
- **Test isolation** - ensure tests don't interfere with each other
- **Mock validation** - verify mocks properly simulate real behavior

### Test Lanes

- **`t`**: Project tests only (no coverage) - fast feedback
- **`tc`/`tcw`**: Tests with coverage - comprehensive validation
- **Build-before-test**: Enabled via Nx target defaults with cache
- **Avoid `-s` unless diagnosing cache issues**

## Command Execution & Tooling

### PAX Alias Mandate

- **ALWAYS use `pax` aliases** for all project operations
- **NEVER fall back to npm/nx directly** unless explicitly requested
- **Primary discovery**: `pax help`
- **Deviation prevention**: Any deviation constitutes a critical failure

#### **Fallback Protocol**

- **Step 1**: Always attempt `pax help` first to discover available aliases
- **Step 2**: Use the appropriate alias for the operation (e.g., `pax dc b` for dynamicons build)
- **Step 3**: Only use direct nx commands if:
    - No appropriate alias exists for the operation
    - The alias command fails and direct nx command is the only alternative
    - Explicitly requested by the user
- **Step 4**: Document any missing aliases that should be added to the PAX system

### Build Tool Preferences

- **Use `--skip-nx-cache`** for troubleshooting Nx build issues
- **Prefer `pnpm` over `npm`** for all package management tasks
- **Use project-specific aliases** - `shared`, `mockly`, `pbc`, `pbe`, etc.

## Anti-Patterns

### ❌ FORBIDDEN: Architectural Violations

- Business logic in extension packages
- Direct VSCode value imports outside shared adapters
- Incomplete consumer updates when modifying shared components
- Skipping quality gates for expediency
- **DI Containers in Guinea Pig Packages**: Never use DI containers in core packages that should be self-contained
- **Custom Test Organization**: Don't create custom test structures when established patterns exist
- **Shared Dependencies in Core Packages**: Never add shared package dependencies to core packages
- **VSCode Extension Configuration Removal**: NEVER remove `contributes`, `activationEvents`, `engines`, or other VSCode extension metadata when refactoring

### ❌ FORBIDDEN: Testing Violations

- Using `vi.mock('vscode')` in shared package tests
- Skipping tests to meet deadlines
- Incomplete mock implementations
- Performance regressions without measurement
- **Bypassing DI Container in Tests**: Never mock the entire DI container - test actual injection patterns
- **Complex Mock Hierarchies**: Avoid elaborate mock setups that compete with real production patterns
- **Ignoring User Testing Insights**: When user identifies testing flaws, investigate architectural implications
- **Surface-Level Problem Fixing**: Don't fix individual test failures without considering systemic architectural issues
- **Large Test File Anti-Pattern**: Never allow test files to exceed 500 lines - split into focused units proactively
- **Architectural Assumption Violations**: Never assume modern packages use specific mocking strategies without user confirmation
- **Timeout-Inducing Tests**: Never create tests that call complex internal methods without mocking them to prevent timeouts
- **Test Simplification Anti-Pattern**: Never simplify tests to the point where they don't verify actual implementation behavior - this defeats regression testing
- **Mock Parameter Mismatches**: Never write mock expectations without understanding actual method signatures, parameter counts, and behavior patterns
- **Service Lifecycle Testing Neglect**: Never test service disposal without first initializing the service to set up disposables
- **Configuration Mocking Oversimplification**: Never underestimate the complexity of mocking platform-specific configuration systems
- **Dynamic Import Violations**: Never use `await import()` for mocking in test files - use static imports with `vi.mocked()`
- **Redundant Mocking**: Never create redundant mocks when standard Vitest mocking patterns are sufficient
- **VS Code Integration Test Environment Violations**: Never skip `VSCODE_TEST='1'` environment variable in `.vscode-test.mjs` configuration
- **UI Operation Test Violations**: Never allow UI operations (like `window.showInformationMessage()`) to execute in test environment without environment detection
- **Module Loading Anti-Pattern**: Never use `--require` parameter when `setupFiles` configuration option is available for VS Code extension tests

### ❌ FORBIDDEN: Documentation Violations

- Skipping Actions Log updates for significant changes
- Missing "What Was Tried and Failed" sections
- Incomplete consumer documentation
- Outdated testing strategies
- **Skipping Date Verification**: NEVER write Actions Log entries without verifying actual file modification timestamps
- **Making Up Dates**: NEVER use estimated or guessed dates - always use verified file timestamps
- **Ignoring Date Guidelines**: NEVER ignore explicit date handling requirements in documentation protocols
- **Premature Completion Claims**: NEVER document completion without verification of ALL claimed components

### ❌ FORBIDDEN: Build Violations

- Build-only dependencies in `dependencies` instead of `devDependencies`
- Direct Node.js module imports in extension code
- Missing externalization of third-party dependencies
- Incorrect TypeScript path mappings
- **Caching Packaging Targets**: NEVER cache `package:dev` targets - they create unique timestamped versions
- **Modifying Working Scripts**: NEVER modify working packaging scripts without clear evidence they're the problem
- **Missing .vscodeignore Files**: ALWAYS include `.vscodeignore` files for extensions that need `node_modules` inclusion
- **TypeScript Build Info Conflicts**: NEVER use overlapping output directories for different TypeScript configurations
- **Test Configuration Extends**: NEVER use `extends: "test"` in project.json - use direct executor configuration

### ❌ FORBIDDEN: Validation Violations

- **Strict Error Throwing**: NEVER throw errors for non-critical validation issues - use warnings instead
- **User Experience Neglect**: NEVER prioritize strict validation over user experience for non-blocking issues
- **Phantom Dependency Assumptions**: NEVER assume phantom dependencies are the root cause without verification

### ❌ FORBIDDEN: Tool Configuration Violations

- Hardcoded configuration templates in validation logic
- Templates placed outside the tool package that uses them
- CommonJS path resolution patterns in ES module tools
- Skipping incremental validation of file loading implementations

### ❌ FORBIDDEN: Refactoring Violations

- **Incremental Renaming**: Never rename components partially - execute complete renaming in logical order
- **Pattern Deviation**: Don't create custom solutions when established patterns exist
- **Architectural Assumption Ignorance**: Never ignore user feedback about testing flaws - investigate architectural implications
- **Real Behavior Bypass**: Never test only mock replacements without validating actual runtime behavior
- **Interface-First Violations**: Never implement services before defining complete interface contracts
- **Complex Component Refactoring**: Never refactor complex, interdependent components before establishing patterns with simple components
- **Build-Before-Interface**: Never attempt to build before completing interface definitions and architectural refactoring
